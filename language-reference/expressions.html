
<!DOCTYPE HTML>
<html lang="ja" >
    <head>
        <meta charset="UTF-8">
        <title>式(Expressions) · The Swift Programming Language日本語版</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 5.1.5">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-collapsible-chapters/collapsible-chapters.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expand-active-chapter/expand-active-chapter.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-insert-logo/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-intopic-toc/style.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/honkit-plugin-prism/prism.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="statements.html" />
    
    
    <link rel="prev" href="types.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="検索ワードを入力" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    The Swift Programming Language(日本語版)
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Swiftへようこそ(WELCOME TO SWIFT)</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../welcome-to-swift/about-swift.html">
            
                <a href="../welcome-to-swift/about-swift.html">
            
                    
                    Swiftについて(About Swift)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../welcome-to-swift/version-compatibility.html">
            
                <a href="../welcome-to-swift/version-compatibility.html">
            
                    
                    バージョン互換性(Version Compatibility)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../welcome-to-swift/a-swift-tour.html">
            
                <a href="../welcome-to-swift/a-swift-tour.html">
            
                    
                    Swiftツアー(A Swift Tour)
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">言語ガイド(LANGUAGE GUIDE)</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../language-guide/the-basics.html">
            
                <a href="../language-guide/the-basics.html">
            
                    
                    基本(The Basics)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="../language-guide/basic-operators.html">
            
                <a href="../language-guide/basic-operators.html">
            
                    
                    基本演算子(Basic Operators)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="../language-guide/strings-and-characters.html">
            
                <a href="../language-guide/strings-and-characters.html">
            
                    
                    文字と文字列(Strings and Characters)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.4" data-path="../language-guide/collection-types.html">
            
                <a href="../language-guide/collection-types.html">
            
                    
                    コレクション型(Collection Types)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.5" data-path="../language-guide/control-flow.html">
            
                <a href="../language-guide/control-flow.html">
            
                    
                    制御フロー(Control Flow)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.6" data-path="../language-guide/functions.html">
            
                <a href="../language-guide/functions.html">
            
                    
                    関数(Functions)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.7" data-path="../language-guide/closures.html">
            
                <a href="../language-guide/closures.html">
            
                    
                    クロージャ(Closures)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.8" data-path="../language-guide/enumerations.html">
            
                <a href="../language-guide/enumerations.html">
            
                    
                    列挙型(Enumerations)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.9" data-path="../language-guide/structures-and-classes.html">
            
                <a href="../language-guide/structures-and-classes.html">
            
                    
                    構造体とクラス(Structures and Classes)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.10" data-path="../language-guide/properties.html">
            
                <a href="../language-guide/properties.html">
            
                    
                    プロパティ(Properties)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.11" data-path="../language-guide/methods.html">
            
                <a href="../language-guide/methods.html">
            
                    
                    メソッド(Methods)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.12" data-path="../language-guide/subscripts.html">
            
                <a href="../language-guide/subscripts.html">
            
                    
                    サブスクリプト(Subscripts)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.13" data-path="../language-guide/inheritance.html">
            
                <a href="../language-guide/inheritance.html">
            
                    
                    継承(Inheritance)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.14" data-path="../language-guide/initialization.html">
            
                <a href="../language-guide/initialization.html">
            
                    
                    初期化(Initialization)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.15" data-path="../language-guide/deinitialization.html">
            
                <a href="../language-guide/deinitialization.html">
            
                    
                    デイニシャライゼーション(Deinitialization)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.16" data-path="../language-guide/optional-chaining.html">
            
                <a href="../language-guide/optional-chaining.html">
            
                    
                    オプショナルチェーン(Optional Chaining)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.17" data-path="../language-guide/error-handling.html">
            
                <a href="../language-guide/error-handling.html">
            
                    
                    エラー処理(Error Handling)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.18" data-path="../language-guide/concurrency.html">
            
                <a href="../language-guide/concurrency.html">
            
                    
                    並行処理(Concurrency)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.19" data-path="../language-guide/macros.html">
            
                <a href="../language-guide/macros.html">
            
                    
                    マクロ(Macros)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.20" data-path="../language-guide/type-casting.html">
            
                <a href="../language-guide/type-casting.html">
            
                    
                    型キャスト(Type Casting)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.21" data-path="../language-guide/nested-types.html">
            
                <a href="../language-guide/nested-types.html">
            
                    
                    ネスト型(Nested Types)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.22" data-path="../language-guide/extensions.html">
            
                <a href="../language-guide/extensions.html">
            
                    
                    拡張(Extensions)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.23" data-path="../language-guide/protocols.html">
            
                <a href="../language-guide/protocols.html">
            
                    
                    プロトコル(Protocols)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.24" data-path="../language-guide/generics.html">
            
                <a href="../language-guide/generics.html">
            
                    
                    ジェネリクス(Generics)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.25" data-path="../language-guide/opaque-types.html">
            
                <a href="../language-guide/opaque-types.html">
            
                    
                    Opaque 型とBox プロトコル型(Opaque Types and Boxed Types)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.26" data-path="../language-guide/automatic-reference-counting.html">
            
                <a href="../language-guide/automatic-reference-counting.html">
            
                    
                    自動参照カウント ARC(Automatic Reference Counting)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.27" data-path="../language-guide/memory-safety.html">
            
                <a href="../language-guide/memory-safety.html">
            
                    
                    メモリ安全性(Memory Safety)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.28" data-path="../language-guide/access-control.html">
            
                <a href="../language-guide/access-control.html">
            
                    
                    アクセス制御(Access Control)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.29" data-path="../language-guide/advanced-operators.html">
            
                <a href="../language-guide/advanced-operators.html">
            
                    
                    高度な演算子(Advanced Operators)
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">言語リファレンス(LANGUAGE REFERENCE)</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="about-the-language-reference.html">
            
                <a href="about-the-language-reference.html">
            
                    
                    言語リファレンスについて(About the Language Reference)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="lexical-structure.html">
            
                <a href="lexical-structure.html">
            
                    
                    字句構造(Lexical Structure)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="types.html">
            
                <a href="types.html">
            
                    
                    型(Types)
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="4.4" data-path="expressions.html">
            
                <a href="expressions.html">
            
                    
                    式(Expressions)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.5" data-path="statements.html">
            
                <a href="statements.html">
            
                    
                    文(Statements)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.6" data-path="declarations.html">
            
                <a href="declarations.html">
            
                    
                    宣言(Declarations)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.7" data-path="attributes.html">
            
                <a href="attributes.html">
            
                    
                    属性(Attributes)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.8" data-path="patterns.html">
            
                <a href="patterns.html">
            
                    
                    パターン(Patterns)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.9" data-path="generic-parameters-and-arguments.html">
            
                <a href="generic-parameters-and-arguments.html">
            
                    
                    ジェネリックパラメータと引数(Generic Parameters and Arguments)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.10" data-path="summary-of-the-grammar.html">
            
                <a href="summary-of-the-grammar.html">
            
                    
                    文法のまとめ(Summary of the Grammar)
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">REVISION HISTORY (改訂履歴)</li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../revision-history/document-revision-history.html">
            
                <a href="../revision-history/document-revision-history.html">
            
                    
                    ドキュメント改訂履歴(Document Revision History)
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            HonKitで公開 
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >式(Expressions)</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <html><head></head><body><h1 id="式expressions">式(Expressions)</h1>
<p>最終更新日: 2024/6/26
原文: <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html" target="_blank">https://docs.swift.org/swift-book/ReferenceManual/Expressions.html</a></p>
<p>型、演算子、変数、およびその他の名前と構造を紹介する。</p>
<p>Swift では、前置式、バイナリ式、基本式、後置式の 4 種類の式があります。式が評価されると、値を返すか、副作用を起こすか、またはその両方を引き起こします。</p>
<p>前置式とバイナリ式を使用すると、演算子をより小さな式に適用できます。基本式は概念的には最もシンプルな種類の式で、値にアクセスする方法を提供します。後置式は、前置式やバイナリ式と同様に、関数呼び出しやメンバアクセスなど、後置式を使用してより複雑な式を構築できます。各式は、下記のセクションで詳しく説明されています。</p>
<blockquote>
<p>Grammar of an expression:</p>
<p><em>expression</em> → <em>try-operator</em><em>?</em> <em>await-operator</em><em>?</em> <em>prefix-expression</em> <em>infix-expressions</em><em>?</em> \</p>
</blockquote>
<h2 id="前置式prefix-expressions">前置式(Prefix Expressions)</h2>
<p>前置式は、式と任意の前置演算子を組み合わせます。前置演算子は 1 つの引数を受け取り、その後に式が続きます。</p>
<p>これらの演算子の動作については、<a href="../language-guide/basic-operators.html">Basic Operators(基本演算子)</a>と<a href="../language-guide/advanced-operators.html">Advanced Operators(高度な演算子)</a>を参照ください。</p>
<p>Swift 標準ライブラリによって提供されている演算子については、<a href="https://developer.apple.com/documentation/swift/swift_standard_library/operator_declarations" target="_blank">Operator Declarations(演算子宣言)</a>を参照ください。</p>
<blockquote>
<p>Grammar of a prefix expression:</p>
<p><em>prefix-expression</em> → <em>prefix-operator</em><em>?</em> <em>postfix-expression</em> \
<em>prefix-expression</em> → <em>in-out-expression</em></p>
</blockquote>
<h3 id="in-out-式in-out-expression">In-Out 式(In-Out Expression)</h3>
<p>in-out 式は、関数呼び出し式に in-out パラメータとして渡された変数にマークをします。</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&amp;&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span>
</code></pre>
<p>in-out パラメータの詳細については、<a href="declarations.html#declarations-in-out-parameters">In-Out Parameters(In-Out パラメータ)</a>を参照ください。</p>
<p>in-out 式は、<a href="expressions.html#implicit-conversion-to-a-pointer-type">Implicit Conversion to a Pointer Type(ポインタ型への暗黙変換)</a>で説明されているように、ポインタが必要なコンテキストに非ポインタ引数を指定するときにも使用されます。</p>
<blockquote>
<p>Grammar of an in-out expression:</p>
<p><em>in-out-expression</em> → <strong><code>&amp;</code></strong> <em>primary-expression</em></p>
</blockquote>
<h3 id="try-演算子try-operator"><a id="try-operator">Try 演算子(Try Operator)</a></h3>
<p><em>Try 演算子</em>は、<code>try</code> 演算子の後にエラーをスローできる式が続く形で構成されます。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">try</span> <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span>
</code></pre>
<p><code>try</code> 式の値は <em>expression</em> の値です。</p>
<p><em>オプショナル try 式</em>は <code>try?</code> 演算子の後にエラーをスローできる式が続く形で構成されます。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">try</span><span class="token operator">?</span> <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span>
</code></pre>
<p>式がエラーをスローしない場合、<code>try?</code> の値は式の値を含むオプショナルです。それ以外の場合、<code>try?</code> の値は <code>nil</code> です。</p>
<p><em>強制 try 式</em>は <code>try!</code> 演算子の後にエラーをスローできる式が続く形で構成されます。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">try</span><span class="token operator">!</span> <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span>
</code></pre>
<p><code>try!</code> の値は <em>experssion</em> の値です。式がエラーをスローすると、実行時エラーが発生します。</p>
<p>バイナリ演算子の左側の式に <code>try</code>、<code>try?</code> または <code>try!</code>、がマークされている場合、その演算子はバイナリ式全体に適用されます。一方で、括弧(<code>()</code>)を使用して、演算子の適用範囲を明示することもできます。</p>
<pre class="language-"><code class="lang-swift"><span class="token comment">//両方の関数呼び出しに適用されます</span>
sum <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">someThrowingFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">anotherThrowingFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">//両方の関数呼び出しに適用されます</span>
sum <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token function">someThrowingFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">anotherThrowingFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">//エラー：最初の関数呼び出しにのみ適用されます</span>
sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">try</span> <span class="token function">someThrowingFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">anotherThrowingFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>バイナリ演算子が代入演算子の場合、または <code>try</code> 式が括弧で囲まれていない限り、<code>try</code> 式はバイナリ演算子の右側には使用できません。</p>
<p><code>try</code> と <code>await</code> 演算子の両方を含む場合は、最初に <code>try</code> が来なければなりません。</p>
<p><code>try</code>、<code>try?</code> と <code>try!</code> の使用方法についての詳細は<a href="../language-guide/error-handling.html">Error Handling(エラーハンドリング)</a>を参照ください。</p>
<blockquote>
<p>Grammar of a try expression:</p>
<p><em>try-operator</em> → <strong><code>try</code></strong> | <strong><code>try</code></strong> <strong><code>?</code></strong> | <strong><code>try</code></strong> <strong><code>!</code></strong></p>
</blockquote>
<h3 id="await-演算子await-operator"><a id="await-operator">Await 演算子(Await Operator)</a></h3>
<p><em>await 式</em>は、<code>await</code> 演算子の後に非同期関数の結果を返す式が続けて構成されます。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">await</span> <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span>
</code></pre>
<p><code>await</code> 式の値は <em>experssion</em> の値です。</p>
<p><code>await</code> でマークされた式を<em>潜在的中断ポイント</em>と呼びます。非同期関数の実行は、<code>await</code> でマークされている箇所で中断することができます。また、並行コードの実行は他の点で中断されることはありません。つまり、潜在的中断ポイント間で、次の潜在的中断ポイントに行く前に状態の更新が完了する条件で、一時的に破壊された不変式を必要とする状態を、安全に更新することができます。</p>
<p><code>await</code> 式は、<code>async(priority:operation:)</code> 関数に渡される末尾クロージャのように、非同期コンテキスト内でのみ使用することができます。<code>defer</code> 文、または同期関数型の自動クロージャでは使用できません。</p>
<p>バイナリ演算子の左側の式に <code>await</code> 演算子がマークされている場合、その演算子はバイナリ式全体に適用されます。ただし、括弧を使用して、演算子の適用範囲について明示することができます。</p>
<pre class="language-"><code class="lang-swift"><span class="token comment">//両方の関数呼び出しに適用されます</span>
sum <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">someAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">anotherAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">//両方の関数呼び出しに適用されます</span>
sum <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token function">someAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">anotherAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">//エラー：最初の関数呼び出しにのみ適用されます</span>
sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token function">someAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">anotherAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>バイナリ演算子が代入演算子の場合、または <code>await</code> 式が括弧内に囲まれていない限り、<code>await</code> 式はバイナリ演算子の右側に使用できません。</p>
<p>式が <code>await</code> と <code>try</code> 演算子の両方を含む場合、最初に <code>try</code> 演算子が来なければなりません。</p>
<blockquote>
<p>Grammar of an await expression:</p>
<p><em>await-operator</em> → <strong><code>await</code></strong></p>
</blockquote>
<h2 id="中置式infix-expressions">中置式(Infix Expressions)</h2>
<p><em>中置式</em>は、左右の引数を受け取る式と中置バイナリ演算子を組み合わせます。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token other-directive property">#left</span><span class="token operator">-</span>hand argument#<span class="token operator">&gt;</span> <span class="token operator">&lt;</span><span class="token other-directive property">#operator</span>#<span class="token operator">&gt;</span> <span class="token operator">&lt;</span><span class="token other-directive property">#right</span><span class="token operator">-</span>hand argument#<span class="token operator">&gt;</span>
</code></pre>
<p>これらの演算子の動作については、<a href="../language-guide/basic-operators.html">Basic Operators(基本演算子)</a> と <a href="../language-guide/advanced-operators.html">Advanced Operators(高度な演算子)</a>を参照ください。</p>
<p>標準ライブラリによって提供されている演算子については、<a href="https://developer.apple.com/documentation/swift/operator_declarations" target="_blank">Operator Declarations(演算子宣言)</a>を参照ください。</p>
<blockquote>
<p>NOTE
構文解析時には、式はバイナリ演算子のフラットなリストを構成します。このリストは、演算子の優先順位を適用することによってツリーに変換されます。例えば、式 <code>2 + 3 * 5</code> は、最初は5つの項目、<code>2</code>、<code>+</code>、<code>3</code>、<code>*</code>、および <code>5</code> として解釈され、その後 <code>(2 + (3 * 5))</code> のツリーに変換します</p>
<p>Grammar of an infix expression:</p>
<p><em>infix-expression</em> → <em>infix-operator</em> <em>prefix-expression</em> \
<em>infix-expression</em> → <em>assignment-operator</em> <em>try-operator</em><em>?</em> <em>await-operator</em><em>?</em> <em>prefix-expression</em> \
<em>infix-expression</em> → <em>conditional-operator</em> <em>try-operator</em><em>?</em> <em>await-operator</em><em>?</em> <em>prefix-expression</em> \
<em>infix-expression</em> → <em>type-casting-operator</em> \
<em>infix-expressions</em> → <em>infix-expression</em> <em>infix-expressions</em><em>?</em></p>
</blockquote>
<h3 id="代入演算子assignment-operator">代入演算子(Assignment Operator)</h3>
<p>代入演算子は特定の式に新しい値を設定します。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token other-directive property">#value</span>#<span class="token operator">&gt;</span>
</code></pre>
<p>value を評価した結果得られた値が expression に設定されます。式がタプルの場合、値は同じ数の要素を持つタプルでなければなりません。(タプルはネストすることもできます)。代入は、値の各部分から expression の中の対応する部分に対して行われます。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token omit keyword">_</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"test"</span></span><span class="token punctuation">,</span> <span class="token number">9.45</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// a は"test"、 b は 12、 c は 3、 9.45 は無視されます</span>
</code></pre>
<p>代入演算子は任意の値を返しません。</p>
<blockquote>
<p>Grammar of an assignment operator:</p>
<p><em>assignment-operator</em> → <strong><code>=</code></strong></p>
</blockquote>
<h3 id="三項条件演算子ternary-conditional-operator">三項条件演算子(Ternary Conditional Operator)</h3>
<p>三項条件演算子は、条件の値に基づいて、2 つの値のうちの 1 つに評価されます。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token other-directive property">#condition</span>#<span class="token operator">&gt;</span> <span class="token operator">?</span> <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span> used <span class="token keyword">if</span> <span class="token boolean">true</span>#<span class="token operator">&gt;</span> <span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span> used <span class="token keyword">if</span> <span class="token boolean">false</span>#<span class="token operator">&gt;</span>
</code></pre>
<p>条件が <code>true</code> と評価された場合、条件演算子は最初の式を評価し、その値を返します。それ以外の場合は、2 番目の式を評価してその値を返します。未使用の式は評価されません。</p>
<p>三項条件演算子を使用する例については、<a href="../language-guide/basic-operators.html#basic-operator-ternary-conditional-operator">Ternary Conditional Operator(三項条件演算子)</a>を参照ください。</p>
<blockquote>
<p>Grammar of a conditional operator:</p>
<p><em>conditional-operator</em> → <strong><code>?</code></strong> <em>expression</em> <strong><code>:</code></strong></p>
</blockquote>
<h3 id="type-casting-operators型キャスト演算子"><a id="type-casting-operators">Type-Casting Operators(型キャスト演算子)</a></h3>
<p>4 つの型キャスト演算子があります: <code>is</code> 演算子、<code>as</code> 演算子、<code>as?</code> 演算子、そして <code>as!</code> 演算子。</p>
<p>それらは次の形式を持っています:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span> <span class="token keyword">is</span> <span class="token operator">&lt;</span><span class="token other-directive property">#type</span>#<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span> <span class="token keyword">as</span> <span class="token operator">&lt;</span><span class="token other-directive property">#type</span>#<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span> <span class="token keyword">as</span><span class="token operator">?</span> <span class="token operator">&lt;</span><span class="token other-directive property">#type</span>#<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span> <span class="token keyword">as</span><span class="token operator">!</span> <span class="token operator">&lt;</span><span class="token other-directive property">#type</span>#<span class="token operator">&gt;</span>
</code></pre>
<p><code>is</code> 演算子は実行時に式が指定された型にキャストできるかどうかを確認します。キャストできる場合は <code>true</code> を返します。それ以外の場合は、<code>false</code> を返します。</p>
<p><code>as</code> 演算子は、コンパイル時にキャストが常に成功するとわかっている場合にキャストを実行します。アップキャストは、中間変数を使用せずに型のスーパー型のインスタンスとして式を使用できます。下記のアプローチはどれも同等です。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">func</span> <span class="token function-definition function">f</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> any<span class="token punctuation">:</span> <span class="token keyword">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Function for Any"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function-definition function">f</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> int<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Function for Int"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token comment">// Function for Int</span>

<span class="token keyword">let</span> y<span class="token punctuation">:</span> <span class="token keyword">Any</span> <span class="token operator">=</span> x
<span class="token function">f</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token comment">// Function for Any</span>

<span class="token function">f</span><span class="token punctuation">(</span>x <span class="token keyword">as</span> <span class="token keyword">Any</span><span class="token punctuation">)</span>
<span class="token comment">// Function for Any</span>
</code></pre>
<p>ブリッジングを使用して、新しいインスタンスを作成せずに、<code>String</code> などの Swift 標準ライブラリ型の式を、それに相応する <code>NSString</code> などの Foudation 型で使用できるようにしています。ブリッジングの詳細については、<a href="https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types" target="_blank">Working with Foundation Types</a>を参照ください。</p>
<p><code>as?</code> 演算子は、式の指定された<em>型</em>への条件付きキャストを実行します。<code>as?</code> 演算子は指定された<em>型</em>のオプショナルを返します。実行時に、キャストが成功した場合、<em>式</em>の値がオプショナルで返されます。それ以外の場合、返される値は <code>nil</code> です。指定された<em>型</em>へのキャストが失敗するか、成功することが明らかな場合は、コンパイルエラーが発生します。</p>
<p><code>as!</code> 演算子は、指定された型に強制キャストを実行します。<code>as!</code> 演算子は、オプショナル型ではなく、指定された型の値を返します。キャストが失敗した場合は、実行時エラーが発生します。<code>x as! T</code> は <code>(x as? T)!</code> の挙動と同じです。</p>
<p>型キャストの詳細や型キャスト演算子を使用する例については、<a href="../language-guide/type-casting.html">Type Casting(型キャスト)</a>を参照ください。</p>
<blockquote>
<p>Grammar of a type-casting operator:</p>
<p><em>type-casting-operator</em> → <strong><code>is</code></strong> <em>type</em> \
<em>type-casting-operator</em> → <strong><code>as</code></strong> <em>type</em> \
<em>type-casting-operator</em> → <strong><code>as</code></strong> <strong><code>?</code></strong> <em>type</em> \
<em>type-casting-operator</em> → <strong><code>as</code></strong> <strong><code>!</code></strong> <em>type</em></p>
</blockquote>
<h2 id="基本式primary-expressions">基本式(Primary Expressions)</h2>
<p>基本式は最も基本的な種類の式です。それらは自身を式として使用したり、他のトークンと組み合わせたり、前置式、バイナリ式、および後置式を作成することができます。</p>
<blockquote>
<p>Grammar of a primary expression:</p>
<p><em>primary-expression</em> → <em>identifier</em> <em>generic-argument-clause</em><em>?</em> \
<em>primary-expression</em> → <em>literal-expression</em> \
<em>primary-expression</em> → <em>self-expression</em> \
<em>primary-expression</em> → <em>superclass-expression</em> \
<em>primary-expression</em> → <em>conditional-expression</em> \
<em>primary-expression</em> → <em>closure-expression</em> \
<em>primary-expression</em> → <em>parenthesized-expression</em> \
<em>primary-expression</em> → <em>tuple-expression</em> \
<em>primary-expression</em> → <em>implicit-member-expression</em> \
<em>primary-expression</em> → <em>wildcard-expression</em> \
<em>primary-expression</em> → <em>macro-expansion-expression</em> \
<em>primary-expression</em> → <em>key-path-expression</em> \
<em>primary-expression</em> → <em>selector-expression</em> \
<em>primary-expression</em> → *key-path-string-expression</p>
</blockquote>
<h3 id="リテラル式literal-expression"><a id="literal-expression">リテラル式(Literal Expression)</a></h3>
<p>リテラル式は、通常のリテラル(文字列や数など)、配列または辞書リテラル、playground リテラルで構成されます。</p>
<blockquote>
<p>NOTE
Swift 5.9以前は、以下の特殊リテラルが認識されていました:
<code>#column</code>, <code>#dsohandle</code> , <code>#fileID</code>, <code>#filePath</code>, <code>#file</code>, <code>#function</code>, <code>#line</code>。
現在はSwift標準ライブラリのマクロとして実装されています:
<a href="https://developer.apple.com/documentation/swift/column(" target="_blank"><code>column</code></a>),
<a href="https://developer.apple.com/documentation/swift/dsohandle(" target="_blank"><code>dsohandle</code></a>),
<a href="https://developer.apple.com/documentation/swift/fileID(" target="_blank"><code>fileID</code></a>),
<a href="https://developer.apple.com/documentation/swift/filePath(" target="_blank"><code>filePath</code></a>),
<a href="https://developer.apple.com/documentation/swift/file(" target="_blank"><code>file</code></a>),
<a href="https://developer.apple.com/documentation/swift/function(" target="_blank"><code>function</code></a>),
<a href="https://developer.apple.com/documentation/swift/line(" target="_blank"><code>line</code></a>)。</p>
</blockquote>
<p><em>配列リテラル</em>は、順序付けられた値の集合です。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token other-directive property">#value</span> <span class="token number">1</span>#<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token other-directive property">#value</span> <span class="token number">2</span>#<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>#<span class="token operator">...</span>#<span class="token operator">&gt;</span><span class="token punctuation">]</span>
</code></pre>
<p>配列内の最後の式の後にカンマ(<code>,</code>)を続けることもできます。配列リテラルの値は <code>[T]</code> 型で、<code>T</code> はその内部の式の型です。複数の型の式がある場合、<code>T</code> はそれらに最も近い共通のスーパー型になります。空の配列リテラルは、空の角括弧(<code>[]</code>)を使用し、指定された型の空の配列を作成するためにも使用できます。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">var</span> emptyArray<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Double</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre>
<p><em>辞書リテラル</em>は、順序のないキーバリューペアのコレクションです。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token other-directive property">#key</span> <span class="token number">1</span>#<span class="token operator">&gt;</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token other-directive property">#value</span> <span class="token number">1</span>#<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token other-directive property">#key</span> <span class="token number">2</span>#<span class="token operator">&gt;</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token other-directive property">#value</span> <span class="token number">2</span>#<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>#<span class="token operator">...</span>#<span class="token operator">&gt;</span><span class="token punctuation">]</span>
</code></pre>
<p>辞書内の最後の式の後にカンマ(<code>,</code>)を続けることができます。辞書リテラルの値は <code>[Key：Value]</code> 型で、<code>Key</code> はそのキー式の型、<code>Value</code> はその値式の型です。複数の型の式がある場合、キーとバリューはそれぞれの値に最も近い共通のスーパー型になります。空の辞書リテラルは、空の配列リテラルと区別するために、一対の括弧内にコロンを書きます(<code>[:]</code>)。空の辞書リテラルを使用して、指定されたキーとバリュー型の空の辞書リテラルを作成できます。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">var</span> emptyDictionary<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
</code></pre>
<p><em>playground リテラル</em>は、プログラムエディタ内の色、ファイル、または画像の対話型な表現を作成するために Xcode によって使用されます。Xcode の外側のプレーンテキストの <code>playground</code> リテラルには、特別なリテラル構文を使用します。</p>
<p>Xcode の playground リテラルの使用方法については、Xcode ヘルプ内の<a href="https://help.apple.com/xcode/mac/current/#/dev4c60242fc" target="_blank">Add a color, file, or image literal</a>を参照ください。</p>
<blockquote>
<p>Grammar of a literal expression:</p>
<p><em>literal-expression</em> → <em>literal</em> \
<em>literal-expression</em> → <em>array-literal</em> | <em>dictionary-literal</em> | <em>playground-literal</em></p>
<p><em>array-literal</em> → <strong><code>[</code></strong> <em>array-literal-items</em><em>?</em> <strong><code>]</code></strong> \
<em>array-literal-items</em> → <em>array-literal-item</em> <strong><code>,</code></strong><em>?</em> | <em>array-literal-item</em> <strong><code>,</code></strong> <em>array-literal-items</em> \
<em>array-literal-item</em> → <em>expression</em></p>
<p><em>dictionary-literal</em> → <strong><code>[</code></strong> <em>dictionary-literal-items</em> <strong><code>]</code></strong> | <strong><code>[</code></strong> <strong><code>:</code></strong> <strong><code>]</code></strong> \
<em>dictionary-literal-items</em> → <em>dictionary-literal-item</em> <strong><code>,</code></strong><em>?</em> | <em>dictionary-literal-item</em> <strong><code>,</code></strong> <em>dictionary-literal-items</em> \
<em>dictionary-literal-item</em> → <em>expression</em> <strong><code>:</code></strong> <em>expression</em></p>
<p><em>playground-literal</em> → <strong><code>#colorLiteral</code></strong> <strong><code>(</code></strong> <strong><code>red</code></strong> <strong><code>:</code></strong> <em>expression</em> <strong><code>,</code></strong> <strong><code>green</code></strong> <strong><code>:</code></strong> <em>expression</em> <strong><code>,</code></strong> <strong><code>blue</code></strong> <strong><code>:</code></strong> <em>expression</em> <strong><code>,</code></strong> <strong><code>alpha</code></strong> <strong><code>:</code></strong> <em>expression</em> <strong><code>)</code></strong> \
<em>playground-literal</em> → <strong><code>#fileLiteral</code></strong> <strong><code>(</code></strong> <strong><code>resourceName</code></strong> <strong><code>:</code></strong> <em>expression</em> <strong><code>)</code></strong> \
<em>playground-literal</em> → <strong><code>#imageLiteral</code></strong> <strong><code>(</code></strong> <strong><code>resourceName</code></strong> <strong><code>:</code></strong> <em>expression</em> <strong><code>)</code></strong></p>
</blockquote>
<h3 id="self-式self-expression">self 式(Self Expression)</h3>
<p><code>self</code> 式は、それが使用さえている現在の型またはインスタンスへの明示的な参照です。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">self</span>
<span class="token keyword">self</span><span class="token operator">.&lt;</span><span class="token other-directive property">#member</span> name#<span class="token operator">&gt;</span>
<span class="token keyword">self</span><span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token other-directive property">#subscript</span> index#<span class="token operator">&gt;</span><span class="token punctuation">]</span>
<span class="token keyword">self</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#initializer</span> arguments#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
<span class="token keyword">self</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#initializer</span> arguments#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<p>イニシャライザ、サブスクリプト、またはインスタンスメソッドでは、<code>self</code> は、それが出現する現在の型のインスタンスを表します。型メソッドでは、<code>self</code> はそれが登場する現在の型を表します。</p>
<p><code>self</code> 式は、関数パラメータなどスコープ内に同じ名前の別の変数があり、何を指すのかが曖昧な場合に、メンバへアクセスするときに指定します。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> greeting<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>greeting<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>greeting <span class="token operator">=</span> greeting
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>値型の mutating メソッドでは、その値型の新しいインスタンスを <code>self</code> に代入できます。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0.0</span>
    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">moveBy</span><span class="token punctuation">(</span>x deltaX<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">,</span> y deltaY<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> x <span class="token operator">+</span> deltaX<span class="token punctuation">,</span> y<span class="token punctuation">:</span> y <span class="token operator">+</span> deltaY<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>Grammar of a self expression:</p>
<p><em>self-expression</em> → <strong><code>self</code></strong> | <em>self-method-expression</em> | <em>self-subscript-expression</em> | <em>self-initializer-expression</em></p>
<p><em>self-method-expression</em> → <strong><code>self</code></strong> <strong><code>.</code></strong> <em>identifier</em> \
<em>self-subscript-expression</em> → <strong><code>self</code></strong> <strong><code>[</code></strong> <em>function-call-argument-list</em> <strong><code>]</code></strong> \
<em>self-initializer-expression</em> → <strong><code>self</code></strong> <strong><code>.</code></strong> <strong><code>init</code></strong></p>
</blockquote>
<h3 id="スーパークラス式superclass-expression">スーパークラス式(Superclass Expression)</h3>
<p><em>スーパークラス式</em>は、クラスがスーパークラスとやり取りすることを可能にします。次のいずれかの形式があります:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">super</span><span class="token operator">.&lt;</span><span class="token other-directive property">#member</span> name#<span class="token operator">&gt;</span>
<span class="token keyword">super</span><span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token other-directive property">#subscript</span> index#<span class="token operator">&gt;</span><span class="token punctuation">]</span>
<span class="token keyword">super</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#initializer</span> arguments#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<p>最初の形式はスーパークラスのメンバにアクセスするために使用されます。2 番目の形式は、スーパークラスのサブスクリプトの実装にアクセスするために使用されます。3 番目の形式は、スーパークラスのイニシャライザにアクセスするために使用されます。</p>
<p>サブクラスは、スーパークラスの実装を利用するために、メンバ、サブスクリプト、およびイニシャライザの実装でスーパークラス式を使用できます。</p>
<blockquote>
<p>Grammar of a superclass expression:</p>
<p><em>superclass-expression</em> → <em>superclass-method-expression</em> | <em>superclass-subscript-expression</em> | <em>superclass-initializer-expression</em></p>
<p><em>superclass-method-expression</em> → <strong><code>super</code></strong> <strong><code>.</code></strong> <em>identifier</em> \
<em>superclass-subscript-expression</em> → <strong><code>super</code></strong> <strong><code>[</code></strong> <em>function-call-argument-list</em> <strong><code>]</code></strong> \
<em>superclass-initializer-expression</em> → <strong><code>super</code></strong> <strong><code>.</code></strong> <strong><code>init</code></strong></p>
</blockquote>
<h3 id="条件式conditional-expression">条件式(Conditional Expression)</h3>
<p><em>条件式</em>は、条件の値に基づいて、与えられたいくつかの値のうちの 1 つに評価されます。</p>
<p>形式は次の通りです:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">if</span> <span class="token operator">&lt;</span><span class="token other-directive property">#condition</span> <span class="token number">1</span>#<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
   <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span> used <span class="token keyword">if</span> condition <span class="token number">1</span> <span class="token keyword">is</span> <span class="token boolean">true</span>#<span class="token operator">&gt;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token operator">&lt;</span><span class="token other-directive property">#condition</span> <span class="token number">2</span>#<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
   <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span> used <span class="token keyword">if</span> condition <span class="token number">2</span> <span class="token keyword">is</span> <span class="token boolean">true</span>#<span class="token operator">&gt;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span> used <span class="token keyword">if</span> both conditions are <span class="token boolean">false</span>#<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
<span class="token keyword">switch</span> <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token operator">&lt;</span><span class="token other-directive property">#pattern</span> <span class="token number">1</span>#<span class="token operator">&gt;</span><span class="token punctuation">:</span>
    <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span> <span class="token number">1</span>#<span class="token operator">&gt;</span>
<span class="token keyword">case</span> <span class="token operator">&lt;</span><span class="token other-directive property">#pattern</span> <span class="token number">2</span>#<span class="token operator">&gt;</span> <span class="token keyword">where</span> <span class="token operator">&lt;</span><span class="token other-directive property">#condition</span>#<span class="token operator">&gt;</span><span class="token punctuation">:</span>
    <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span> <span class="token number">2</span>#<span class="token operator">&gt;</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span> <span class="token number">3</span>#<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>条件式は、<code>if</code> 文や <code>switch</code> 文と同じ動作と構文ですが、以下の段落で説明する違いがあります。</p>
<p>条件式は、以下の状況でのみ使用できます:</p>
<ul>
<li>変数に代入される値として</li>
<li>変数または定数宣言の初期値として</li>
<li><code>throw</code> 式が投げるエラーとして</li>
<li>関数、クロージャ、プロパティの <code>get</code> が返す値として</li>
<li>条件式の分岐内の値として</li>
</ul>
<p>条件式の分岐は網羅的であり、条件に関係なく常に値を生成することを保証します。つまり、各 <code>if</code> 分岐には対応する <code>else</code> 分岐が必要です。</p>
<p>各分岐には、その分岐の条件が真である場合に条件式の値として使用される単一式、<code>throw</code> 文、または戻り値を返さない関数への呼び出しが含まれます。</p>
<p>各分岐は、同じ型の値を生成する必要があります。各分岐の型チェックは独立しているので、分岐に異なる種類のリテラルを含む場合や、分岐の値が <code>nil</code> である場合など、値の型を明示的に指定する必要がある場合があります。このような情報を提供する必要がある場合は、結果が代入される変数に型注釈を追加するか、分岐の値に <code>as</code> キャストを追加してください。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">let</span> number<span class="token punctuation">:</span> <span class="token class-name">Double</span> <span class="token operator">=</span> <span class="token keyword">if</span> someCondition <span class="token punctuation">{</span> <span class="token number">10</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token number">12.34</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token keyword">if</span> someCondition <span class="token punctuation">{</span> <span class="token number">10</span> <span class="token keyword">as</span> <span class="token class-name">Double</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token number">12.34</span> <span class="token punctuation">}</span>
</code></pre>
<p>リザルトビルビルダの内部では、条件式は変数や定数の初期値としてのみ使用することができます。つまり、変数や定数の宣言のないリザルトビルダ内で <code>if</code> や <code>switch</code> を記述すると、そのコードは分岐文として理解され、リザルトビルダのメソッドの 1 つが、そのコードを変換することになります。</p>
<p>条件式の分岐の 1 つがエラーをスローする場合でも、条件式を <code>try</code> 式の中に入れてはいけません。</p>
<blockquote>
<p>Grammar of a conditional expression:</p>
<p><em>conditional-expression</em> → <em>if-expression</em> | <em>switch-expression</em></p>
<p><em>if-expression</em> → <strong><code>if</code></strong> <em>condition-list</em> <strong><code>{</code></strong> <em>statement</em> <strong><code>}</code></strong> <em>if-expression-tail</em> \
<em>if-expression-tail</em> → <strong><code>else</code></strong> <em>if-expression</em> \
<em>if-expression-tail</em> → <strong><code>else</code></strong> <strong><code>{</code></strong> <em>statement</em> <strong><code>}</code></strong></p>
<p><em>switch-expression</em> → <strong><code>switch</code></strong> <em>expression</em> <strong><code>{</code></strong> <em>switch-expression-cases</em> <strong><code>}</code></strong> \
<em>switch-expression-cases</em> → <em>switch-expression-case</em> <em>switch-expression-cases</em><em>?</em> \
<em>switch-expression-case</em> → <em>case-label</em> <em>statement</em> \
<em>switch-expression-case</em> → <em>default-label</em> <em>statement</em></p>
</blockquote>
<h3 id="クロージャ式closure-expression">クロージャ式(Closure Expression)</h3>
<p><em>クロージャ式</em>は、他のプログラミング言語では、<em>ラムダ</em>または<em>匿名関数</em>とも呼ばれているクロージャを作成します。関数宣言のように、クロージャには文が含まれており、その囲まれている範囲から定数と変数をキャプチャします。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#parameters</span>#<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token operator">&lt;</span><span class="token other-directive property">#return</span> type#<span class="token operator">&gt;</span> <span class="token keyword">in</span>
   <span class="token operator">&lt;</span><span class="token other-directive property">#statements</span>#<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><a href="declarations.html#function-declaration">Function Declaration(関数宣言)</a>で説明されているように、<em>parameters</em>は関数宣言内のパラメータと同じ形式です。</p>
<p>クロージャ式で <code>throw</code> または <code>async</code> を記述すると、クロージャはエラーをスローする、または非同期であることを明示します。</p>
<pre class="language-"><code class="lang-swift"><span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#parameters</span>#<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token keyword">throws</span> <span class="token operator">-&gt;</span> <span class="token operator">&lt;</span><span class="token other-directive property">#return</span> type#<span class="token operator">&gt;</span> <span class="token keyword">in</span>
   <span class="token operator">&lt;</span><span class="token other-directive property">#statements</span>#<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>クロージャの本文に、全体のエラー処理を伴う <code>do</code> 文内にネストされていない <code>throws</code> ステートメントまたは <code>try</code> 式が含まれている場合、クロージャはエラーをスローするものと見なされます。スローするクロージャが単一のエラーの型のみをスローする場合、クロージャはそのエラーの型をスローするものと認識されます。それ以外の場合は、<code>any Error</code> をスローするものと見なされます。同様に、本文に <code>await</code> 式が含まれている場合、非同期であると見なされます。</p>
<p>クロージャをより簡潔に書くことができるいくつかの特別な形式があります:</p>
<ul>
<li>クロージャは、そのパラメータ、戻り値の型、またはその両方の型を省略できます。パラメータ名と型の両方を省略する場合は、文の前の <code>in</code> キーワードを省略してください。省略された型を推論できない場合は、コンパイルエラーが発生します</li>
<li>クロージャはそのパラメータ名を省略することができます。その際は暗黙的に <code>$0</code>、<code>$1</code>、 <code>$2</code> などのように <code>$</code> の後ろにパラメータの位置を続けた名前が与えられます</li>
<li>単一式からなるクロージャは、その式の値を返すことが明らかです。この式の内容は、囲まれている式の型を推論するときにも使用されます</li>
</ul>
<p>次のクロージャ式は同等です:</p>
<pre class="language-"><code class="lang-swift">myFunction <span class="token punctuation">{</span> <span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token keyword">in</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>

myFunction <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token keyword">in</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>

myFunction <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token short-argument">$0</span> <span class="token operator">+</span> <span class="token short-argument">$1</span> <span class="token punctuation">}</span>

myFunction <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">+</span> <span class="token short-argument">$1</span> <span class="token punctuation">}</span>
</code></pre>
<p>関数の引数としてクロージャを渡す方法については、<a href="expressions.html#function-call-expression">Function Call Expression(関数呼び出し式)</a>を参照ください。</p>
<p>クロージャ式は、関数呼び出しの一部としてすぐにクロージャを使用するときなど、可変または定数に格納されることなく使用できます。上記のコードの <code>myFunction</code> に渡されたクロージャ式は、即時に使用される例です。その結果、クロージャ式がエスケープか非エスケープかは、式の周囲のコンテキストによって異なります。クロージャ式は、即時に呼ばれるか、非エスケープ関数の引数として渡されると、非エスケープです。それ以外の場合、クロージャ式はエスケープです。</p>
<p>クロージャのエスケープの詳細については、<a href="../language-guide/closures.html#escaping-closures" target="_self">Escaping Closures(エスケープクロージャ)</a>を参照ください。</p>
<h4 id="キャプチャリストcapture-lists"><a id="capture-lists">キャプチャリスト(Capture Lists)</a></h4>
<p>デフォルトでは、クロージャ式は、、周囲のスコープの定数と変数を強い参照を持ってキャプチャします。<em>キャプチャリスト</em>を使用して、クロージャ内で値をキャプチャする方法を明示的に制御できます。</p>
<p>キャプチャリストは、パラメータのリストの前に、角括弧(<code>[]</code>)で囲まれた式のカンマ(<code>,</code>)区切りのリストとして書かれます。キャプチャリストを使用する場合は、パラメータ名、パラメータ型、および戻り値の型を省略しても、<code>in</code> キーワードを使用する必要があります。</p>
<p>キャプチャリストへの各エントリは、クロージャが作成されたときに初期化されます。キャプチャリスト内の各エントリに対して、定数は周囲のスコープの同じ名前を持つ定数または変数の値で初期化できます。例えば、下記のコードでは、<code>a</code> はキャプチャリストに含まれていますが、<code>b</code> は含まれていません。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">let</span> closure <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token keyword">in</span>
    <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

a <span class="token operator">=</span> <span class="token number">10</span>
b <span class="token operator">=</span> <span class="token number">10</span>
<span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 0 10</span>
</code></pre>
<p>クロージャの範囲内の定数と周囲の範囲内の変数に <code>a</code> という同じ名前の異なる変数がありますが、<code>b</code> という名前の変数は 1 つだけです。内部スコープ内の <code>a</code> は、クロージャが作成されたときに外側の <code>a</code> 値で初期化されますが、それらの値は繋がっていません。つまり、これは、外側の範囲内の <code>a</code> の値の変化が内側の範囲内の <code>a</code> の値に影響を与えず、クロージャの内側の値の変化も外側の <code>a</code> に影響を与えません。対照的に、<code>b</code> という名前の変数は外側の範囲内に 1 つしかなく、クロージャの内側または外側からの変化は両方に影響を与えます。</p>
<p>キャプチャされた変数の型に参照セマンティクスがある場合、この区別はありません。例えば、下のコードに <code>x</code> という 2 つの変数がありますが、外部スコープの変数と内部スコープの定数は、両方とも参照セマンティクスのために同じオブジェクトを参照します。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">class</span> <span class="token class-name">SimpleClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> value<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token class-name">SimpleClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token class-name">SimpleClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> closure <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">in</span>
    <span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>value<span class="token punctuation">,</span> y<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

x<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">10</span>
y<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">10</span>
<span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 10 10</span>
</code></pre>
<p>式の値の型がクラスの場合は、式の値へ弱参照または非所有参照で取り込むために、キャプチャリスト内の式に <code>weak</code> または <code>unowned</code> をマークすることができます。</p>
<pre class="language-"><code class="lang-swift">myFunction <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>title<span class="token punctuation">)</span> <span class="token punctuation">}</span>                    <span class="token comment">// 暗黙的な強参照</span>
myFunction <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>title<span class="token punctuation">)</span> <span class="token punctuation">}</span>          <span class="token comment">// 明示的な強参照</span>
myFunction <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token keyword">weak</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token operator">!</span><span class="token punctuation">.</span>title<span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token comment">// 弱参照</span>
myFunction <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token keyword">unowned</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>title<span class="token punctuation">)</span> <span class="token punctuation">}</span>  <span class="token comment">// 非所有参照</span>
</code></pre>
<p>任意の式をキャプチャリスト内の名前付きの値にバインドすることもできます。クロージャが作成されたときに式が評価され、値は指定された強度でキャプチャされます。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token comment">// parent として self.parent を弱参照する</span>
myFunction <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token keyword">weak</span> parent <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>parent<span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token function">print</span><span class="token punctuation">(</span>parent<span class="token operator">!</span><span class="token punctuation">.</span>title<span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre>
<p>クロージャ式の詳細と例については、<a href="../language-guide/closures.html#closure-expressions">Closure Expressions(クロージャ式)</a>を参照ください。キャプチャリストの詳細および例については、<a href="../language-guide/automatic-reference-counting.html#resolving-strong-reference-cycles-for-closures">Resolving Strong Reference Cycles for Closures(クロージャの強循環参照の解消)</a>を参照ください。</p>
<blockquote>
<p>Grammar of a closure expression:</p>
<p><em>closure-expression</em> → <strong><code>{</code></strong> <em>attributes</em><em>?</em> <em>closure-signature</em><em>?</em> <em>statements</em><em>?</em> <strong><code>}</code></strong></p>
<p><em>closure-signature</em> → <em>capture-list</em><em>?</em> <em>closure-parameter-clause</em> <strong><code>async</code></strong><em>?</em> <em>throws-clause</em><em>?</em> <em>function-result</em><em>?</em> <strong><code>in</code></strong> \
<em>closure-signature</em> → <em>capture-list</em> <strong><code>in</code></strong></p>
<p><em>closure-parameter-clause</em> → <strong><code>(</code></strong> <strong><code>)</code></strong> | <strong><code>(</code></strong> <em>closure-parameter-list</em> <strong><code>)</code></strong> | <em>identifier-list</em> \
<em>closure-parameter-list</em> → <em>closure-parameter</em> | <em>closure-parameter</em> <strong><code>,</code></strong> <em>closure-parameter-list</em> \
<em>closure-parameter</em> → <em>closure-parameter-name</em> <em>type-annotation</em><em>?</em> \
<em>closure-parameter</em> → <em>closure-parameter-name</em> <em>type-annotation</em> <strong><code>...</code></strong> \
<em>closure-parameter-name</em> → <em>identifier</em></p>
<p><em>capture-list</em> → <strong><code>[</code></strong> <em>capture-list-items</em> <strong><code>]</code></strong> \
<em>capture-list-items</em> → <em>capture-list-item</em> | <em>capture-list-item</em> <strong><code>,</code></strong> <em>capture-list-items</em> \
<em>capture-list-item</em> → <em>capture-specifier</em><em>?</em> <em>identifier</em> \
<em>capture-list-item</em> → <em>capture-specifier</em><em>?</em> <em>identifier</em> <strong><code>=</code></strong> <em>expression</em> \
<em>capture-list-item</em> → <em>capture-specifier</em><em>?</em> <em>self-expression</em> \
<em>capture-specifier</em> → <strong><code>weak</code></strong> | <strong><code>unowned</code></strong> | <strong><code>unowned(safe)</code></strong> | <strong><code>unowned(unsafe)</code></strong></p>
</blockquote>
<h3 id="暗黙メンバ式implicit-member-expression"><a id="implicit-member-expression">暗黙メンバ式(Implicit Member Expression)</a></h3>
<p><em>暗黙メンバ式</em>は、型推論によって暗黙的に型を決定できるコンテキストにおいて、列挙ケースや型メソッドなどの型のメンバにアクセスするための省略記法です。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">.&lt;</span><span class="token other-directive property">#member</span> name#<span class="token operator">&gt;</span>
</code></pre>
<p>例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token class-name">MyEnumeration</span><span class="token punctuation">.</span>someValue
x <span class="token operator">=</span> <span class="token punctuation">.</span>anotherValue
</code></pre>
<p>推論された型がオプショナルの場合は、暗黙メンバ式にオプショナルでない型のメンバを使用することもできます。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">var</span> someOptional<span class="token punctuation">:</span> <span class="token class-name">MyEnumeration</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token punctuation">.</span>someValue
</code></pre>
<p>暗黙メンバ式の後に<a href="expressions.html#postfix-expressions">Postfix Expressions(後置式)</a>でリストされている後置演算子またはその他の後置構文を続けることができます。これは<em>暗黙メンバ式チェーン</em>と呼ばれます。全ての後置式チェーンで同じ型を持つことが一般的ですが、最低限の要件として、暗黙メンバ式チェーン全体がそのコンテキストで暗黙的に推論される型と互換性がある必要があります。具体的には、暗黙的に推論される型がオプショナルの場合は、オプショナル以外の型の値を使用でき、クラス型の場合、そのサブクラスを使用できます。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">var</span> shared <span class="token operator">=</span> <span class="token class-name">SomeClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">static</span> <span class="token keyword">var</span> sharedSubclass <span class="token operator">=</span> <span class="token class-name">SomeSubclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token class-name">AnotherClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">SomeSubclass</span><span class="token punctuation">:</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">AnotherClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token class-name">SomeClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token function-definition function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token class-name">AnotherClass</span><span class="token punctuation">.</span>s <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token class-name">SomeClass</span> <span class="token operator">=</span> <span class="token punctuation">.</span>shared<span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> y<span class="token punctuation">:</span> <span class="token class-name">SomeClass</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token punctuation">.</span>shared
<span class="token keyword">let</span> z<span class="token punctuation">:</span> <span class="token class-name">SomeClass</span> <span class="token operator">=</span> <span class="token punctuation">.</span>sharedSubclass
</code></pre>
<p>上記のコードでは、<code>x</code> の型はそのコンテキストから暗黙的に推論された型と正確に一致し、<code>y</code> の型は <code>SomeClass</code> から <code>SomeClass?</code> に変換され、<code>z</code> の型は <code>SomeSubclass</code> から <code>SomeClass</code> に変換されます。</p>
<blockquote>
<p>Grammar of a implicit member expression:</p>
<p><em>implicit-member-expression</em> → <strong><code>.</code></strong> <em>identifier</em> \
<em>implicit-member-expression</em> → <strong><code>.</code></strong> <em>identifier</em> <strong><code>.</code></strong> <em>postfix-expression</em></p>
</blockquote>
<h3 id="括弧で囲まれた式parenthesized-expression">括弧で囲まれた式(Parenthesized Expression)</h3>
<p><em>括弧で囲まれた式</em>は、括弧で囲まれた式で構成されます。式を明示的にグループ化することで、括弧を使用して操作の優先順位を指定できます。括弧のグループ化は式の型を変更しません(例：<code>(1)</code> はただの <code>Int</code> です。</p>
<blockquote>
<p>Grammar of a parenthesized expression:</p>
<p><em>parenthesized-expression</em> → <strong><code>(</code></strong> <em>expression</em> <strong><code>)</code></strong></p>
</blockquote>
<h3 id="タプル式tuple-expression">タプル式(Tuple Expression)</h3>
<p>タプル式は、括弧で囲まれた式のカンマ区切りのリストで構成されています。各式は、コロン(<code>:</code>)で区切られ、その前に識別子を指定することもできます。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#identifier</span> <span class="token number">1</span>#<span class="token operator">&gt;</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span> <span class="token number">1</span>#<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token other-directive property">#identifier</span> <span class="token number">2</span>#<span class="token operator">&gt;</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token other-directive property">#expression</span> <span class="token number">2</span>#<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>#<span class="token operator">...</span>#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<p><em>タプル式</em>の各識別子は、タプル式の範囲内で一意な必要があります。ネストしたタプル式では、同じレベルでネスト識別子を一意にする必要があります。例えば、<code>(a: 10, a: 20)</code> はラベル <code>a</code> が同じレベルで 2 回使用されているため無効です。ただし、<code>(a: 10, b: (a: 1, x: 2))</code> は有効です。<code>a</code> は 2 回使用されていますが、外側のタプルに 1 回、内側のタプルに 1 回使用されています。</p>
<p>タプル式には、式を全く含めなくても、2 つ以上の式を含めることもできます。括弧内の単一式は括弧で囲まれた式です。</p>
<blockquote>
<p>NOTE
空のタプル式と空のタプル型はいずれもSwiftでは <code>()</code> で書きます。<code>Void</code> は <code>()</code> のタイプエイリアスのため、空のタプル型を書くために使用できます。ただし、全てのタイプエイリアスと同様に、<code>Void</code> は常に型で、空のタプル式を書くためには使用できません。</p>
<p>Grammar of a tuple expression:</p>
<p><em>tuple-expression</em> → <strong><code>(</code></strong> <strong><code>)</code></strong> | <strong><code>(</code></strong> <em>tuple-element</em> <strong><code>,</code></strong> <em>tuple-element-list</em> <strong><code>)</code></strong> \
<em>tuple-element-list</em> → <em>tuple-element</em> | <em>tuple-element</em> <strong><code>,</code></strong> <em>tuple-element-list</em> \
<em>tuple-element</em> → <em>expression</em> | <em>identifier</em> <strong><code>:</code></strong> <em>expression</em></p>
</blockquote>
<h3 id="ワイルドカード式wildcard-expression">ワイルドカード式(Wildcard Expression)</h3>
<p>ワイルドカード式は、代入中に値を明示的に無視するために使用されます。例えば、次の代入式 <code>10</code> は <code>x</code> に代入されますが、<code>20</code> は無視されています:</p>
<pre class="language-"><code class="lang-swift"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token omit keyword">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
<span class="token comment">// x は 10 で 20 は 無視されます</span>
</code></pre>
<blockquote>
<p>Grammar of a wildcard expression:</p>
<p><em>wildcard-expression</em> → <strong><code>_</code></strong></p>
</blockquote>
<h3 id="マクロ展開式macro-expansion-expression">マクロ展開式(Macro-Expansion Expression)</h3>
<p><em>マクロ展開式</em>は、マクロ名と、その後ろに括弧で囲んだカンマ区切りのマクロ引数のリストで構成されます。
マクロはコンパイル時に展開されます。
マクロ展開式は次のような形式をとります:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token other-directive property">#macro</span> name#<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#macro</span> argument <span class="token number">1</span>#<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token other-directive property">#macro</span> argument <span class="token number">2</span>#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<p>マクロ展開式では、マクロ名の後に引数がない場合は括弧を省略します。</p>
<p>マクロ式は、Swift 標準ライブラリの<a href="http://developer.apple.com/documentation/swift/documentation/swift/file" target="_blank"><code>file</code></a>と<a href="http://developer.apple.com/documentation/swift/documentation/swift/line" target="_blank"><code>line</code></a>マクロを除いて、パラメータのデフォルト値に使用することはできません。</p>
<p>これらのマクロは、関数定義に現れる場所ではなく、呼び出し側のソースコードの場所を使って評価されます。</p>
<p>マクロ式を使用して、自立型マクロを呼び出します。付属型マクロを呼び出すためには、<a href="attributes.html">属性(Attributes)</a>で説明されているカスタム属性の構文を使用します。自立型マクロも付属型マクロも、次のように展開されます:</p>
<ol>
<li><p>Swift はソースコードを解析して抽象構文木(AST)を生成する</p>
</li>
<li><p>マクロ実装は、入力値として AST ノードを受け取り、そのマクロで必要な変換を実行する</p>
</li>
<li><p>マクロ実装が生成した変換された AST ノードは、元の AST に追加されます</p>
</li>
</ol>
<p>各マクロの展開は独立しており、自己完結しています。しかし、パフォーマンスを最適化するために、Swift はマクロを実装する外部プロセスを開始し、複数のマクロを展開するために同じプロセスを再利用することもあります。マクロを実装するとき、そのコードは、あなたのコードが以前に展開したマクロや現在の時間のような他の外部状態に依存してはなりません。</p>
<p>入れ子になったマクロや複数の役割を持つ付属型マクロでは、展開処理が繰り返されます。入れ子になったマクロ展開式は、外側から内側へと展開します。たとえば、以下のコードでは <code>outerMacro(_:)</code> が最初に展開され、展開されていない <code>innerMacro(_:)</code> の呼び出しが <code>outerMacro(_:)</code> の入力値として受け取る AST に現れます。</p>
<pre class="language-"><code class="lang-swift"><span class="token other-directive property">#outerMacro</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token other-directive property">#innerMacro</span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"some text"</span></span><span class="token punctuation">)</span>
</code></pre>
<p>複数の役割を持つ付属型マクロは、役割ごとに 1 回ずつ展開されます。それぞれの展開は入力値として同じ元となった AST を受け取ります。Swift は、生成されたすべての AST ノードを収集し、AST を対応する場所に置いて展開されたコード全体を形成します。</p>
<p>Swift のマクロの概要については、<a href="../language-guide/macros.html">マクロ(Macros)</a> を参照してください。</p>
<blockquote>
<p>Grammar of a macro-expansion expression:</p>
<p><em>macro-expansion-expression</em> → <strong><code>#</code></strong> <em>identifier</em> <em>generic-argument-clause</em><em>?</em> <em>function-call-argument-clause</em><em>?</em> <em>trailing-closures</em><em>?</em></p>
</blockquote>
<h3 id="keypath-式key-path-expression"><a id="keypath-expression">KeyPath 式(Key-Path Expression)</a></h3>
<p><em>KeyPath 式</em>は、型のプロパティまたはサブスクリプトを参照します。key-value observing などのような、動的プログラミングのタスクで KeyPath 式を使用します。次の形式があります:</p>
<pre class="language-"><code class="lang-swift"><span class="token punctuation">\</span><span class="token operator">&lt;</span><span class="token other-directive property">#type</span> name#<span class="token operator">&gt;</span><span class="token operator">.&lt;</span><span class="token other-directive property">#path</span>#<span class="token operator">&gt;</span>
</code></pre>
<p><em>type name</em> は、<code>String</code>、<code>[Int]</code>、や <code>Set<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Int</span><span class="token punctuation">&gt;</span></span></code> などのジェネリックなパラメータを含めた、具体的な型の名前です。</p>
<p><em>path</em> は、プロパティ名、サブスクリプト、オプショナルチェーン式、および強制アンラップ式で構成されます。これらの KeyPath コンポーネントのそれぞれは、必要に応じて任意の順序で繰り返すことができます。</p>
<p>コンパイル時には、KeyPath 式は <a href="https://developer.apple.com/documentation/swift/keypath" target="_blank">KeyPath</a>クラスのインスタンスに置き換えられます。</p>
<p>KeyPath を使用して値にアクセスするには、KeyPath を <code>subscript(keyPath:)</code> に渡します。これは全ての型で利用可能です。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">struct</span> <span class="token class-name">SomeStructure</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> someValue<span class="token punctuation">:</span> <span class="token class-name">Int</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">SomeStructure</span><span class="token punctuation">(</span>someValue<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> pathToProperty <span class="token operator">=</span> <span class="token punctuation">\</span><span class="token class-name">SomeStructure</span><span class="token punctuation">.</span>someValue

<span class="token keyword">let</span> value <span class="token operator">=</span> s<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> pathToProperty<span class="token punctuation">]</span>
<span class="token comment">// value は 12</span>
</code></pre>
<p><em>type name</em> は、型推論で暗黙的に型を決定できるコンテキストでは省略できます。次のコードは、<code>\SomeClass.someProperty</code> の代わりに <code>\.someProperty</code> を使用しています:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">class</span> <span class="token class-name">SomeClass</span><span class="token punctuation">:</span> <span class="token class-name">NSObject</span> <span class="token punctuation">{</span>
    <span class="token attribute atrule">@objc</span> <span class="token keyword">dynamic</span> <span class="token keyword">var</span> someProperty<span class="token punctuation">:</span> <span class="token class-name">Int</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>someProperty<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>someProperty <span class="token operator">=</span> someProperty
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">SomeClass</span><span class="token punctuation">(</span>someProperty<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span>
c<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">\</span><span class="token punctuation">.</span>someProperty<span class="token punctuation">)</span> <span class="token punctuation">{</span> object<span class="token punctuation">,</span> change <span class="token keyword">in</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
<p><em>path</em> は、self KeyPath <code>(\.self)</code> を作成するために <code>self</code> を参照できます。self KeyPath は、インスタンス全体を参照しているので、それを使用して、変数に格納されている全てのデータを単一のステップでアクセスして変更できます。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">var</span> compoundValue <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment">// compoundValue = (a: 10, b: 20) と同じ</span>
compoundValue<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> <span class="token punctuation">\</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">)</span>
</code></pre>
<p><em>path</em> には、プロパティのプロパティを参照するために、ピリオドで区切って複数のプロパティ名を含めることができます。このコードは、KeyPath 式 <code>\OuterStructure.outer.someValue</code> を使用して、<code>OuterStructure</code> 型の <code>outer</code> プロパティの <code>someValue</code> プロパティにアクセスしています:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">struct</span> <span class="token class-name">OuterStructure</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> outer<span class="token punctuation">:</span> <span class="token class-name">SomeStructure</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>someValue<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>outer <span class="token operator">=</span> <span class="token class-name">SomeStructure</span><span class="token punctuation">(</span>someValue<span class="token punctuation">:</span> someValue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> nested <span class="token operator">=</span> <span class="token class-name">OuterStructure</span><span class="token punctuation">(</span>someValue<span class="token punctuation">:</span> <span class="token number">24</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> nestedKeyPath <span class="token operator">=</span> <span class="token punctuation">\</span><span class="token class-name">OuterStructure</span><span class="token punctuation">.</span>outer<span class="token punctuation">.</span>someValue

<span class="token keyword">let</span> nestedValue <span class="token operator">=</span> nested<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> nestedKeyPath<span class="token punctuation">]</span>
<span class="token comment">// nestedValue は 24</span>
</code></pre>
<p><em>path</em> は、サブスクリプトのパラメータ型が <code>Hashable</code> プロトコルに準拠している限り角括弧(<code>[]</code>)を使用してサブスクリプトを含めることができます。この例では、KeyPath のサブスクリプトを使用して、配列の 2 番目の要素にアクセスしています。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">let</span> greetings <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"hello"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"hola"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"bonjour"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"안녕"</span></span><span class="token punctuation">]</span>
<span class="token keyword">let</span> myGreeting <span class="token operator">=</span> greetings<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> <span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token comment">// myGreeting は 'hola'</span>
</code></pre>
<p>サブスクリプトで使用される値は、名前付きの値またはリテラルです。値は Value セマンティクスを使用して KeyPath 内にキャプチャされます。次のコードは、KeyPath 式と <code>greetings</code> 配列の 3 番目の要素の両方にアクセスするために、可変の <code>index</code> を使用しています。<code>index</code> が変更されると、KeyPath 式は依然として 3 番目の要素を参照する一方、クロージャは新しいインデックスを使用しています。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">var</span> index <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">let</span> path <span class="token operator">=</span> <span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span>
<span class="token keyword">let</span> fn<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token punctuation">{</span> strings <span class="token keyword">in</span> strings<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token punctuation">}</span>

<span class="token function">print</span><span class="token punctuation">(</span>greetings<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> path<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// bonjour</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span>greetings<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// bonjour</span>

<span class="token comment">// index に新しい値を設定しても、path には影響しません</span>
index <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token function">print</span><span class="token punctuation">(</span>greetings<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> path<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// bonjour</span>

<span class="token comment">// fn が index を参照するので、新しい値を使用しています</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span>greetings<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 안녕</span>
</code></pre>
<p><em>path</em> はオプショナルチェーンと強制アンラップを使用できます。このコードは、オプショナルの文字列のプロパティにアクセスするための KeyPath でオプショナルチェーンを使用しています。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">let</span> firstGreeting<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span> <span class="token operator">=</span> greetings<span class="token punctuation">.</span>first
<span class="token function">print</span><span class="token punctuation">(</span>firstGreeting<span class="token operator">?</span><span class="token punctuation">.</span>count <span class="token keyword">as</span> <span class="token keyword">Any</span><span class="token punctuation">)</span>
<span class="token comment">// Optional(5)</span>

<span class="token comment">// KeyPath を使用して同じことをしています</span>
<span class="token keyword">let</span> count <span class="token operator">=</span> greetings<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> <span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token operator">?</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span>
<span class="token function">print</span><span class="token punctuation">(</span>count <span class="token keyword">as</span> <span class="token keyword">Any</span><span class="token punctuation">)</span>
<span class="token comment">// Optional(5)</span>
</code></pre>
<p>KeyPath のコンポーネントを、型内に深くネストされている値にアクセスために組み合わせることができます。次のコードは、これらのコンポーネントを組み合わせた KeyPath 式を使用して、配列内の辞書のプロパティの様々な値にアクセスしています:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">let</span> interestingNumbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"prime"</span></span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                          <span class="token string-literal"><span class="token string">"triangular"</span></span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                          <span class="token string-literal"><span class="token string">"hexagonal"</span></span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">91</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token function">print</span><span class="token punctuation">(</span>interestingNumbers<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> <span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"prime"</span></span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">Any</span><span class="token punctuation">)</span>
<span class="token comment">// Optional([2, 3, 5, 7, 11, 13, 17])</span>
<span class="token function">print</span><span class="token punctuation">(</span>interestingNumbers<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> <span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"prime"</span></span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 2</span>
<span class="token function">print</span><span class="token punctuation">(</span>interestingNumbers<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> <span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"hexagonal"</span></span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 7</span>
<span class="token function">print</span><span class="token punctuation">(</span>interestingNumbers<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> <span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"hexagonal"</span></span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">.</span>count<span class="token punctuation">.</span>bitWidth<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 64</span>
</code></pre>
<p>関数またはクロージャを使用できるコンテキストでは、KeyPath 式を使用できます。具体的には、<code>(SomeType) -&gt; Value</code> 型の関数やクロージャの代わりに、基の型が <code>SomeType</code> で、そのパスが <code>Value</code> 型の値を生成することができます。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">struct</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> description<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token keyword">var</span> completed<span class="token punctuation">:</span> <span class="token class-name">Bool</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> toDoList <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token class-name">Task</span><span class="token punctuation">(</span>description<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"Practice ping-pong."</span></span><span class="token punctuation">,</span> completed<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Task</span><span class="token punctuation">(</span>description<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"Buy a pirate costume."</span></span><span class="token punctuation">,</span> completed<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Task</span><span class="token punctuation">(</span>description<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"Visit Boston in the Fall."</span></span><span class="token punctuation">,</span> completed<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>

<span class="token comment">// 以下の両方のアプローチは同等です</span>
<span class="token keyword">let</span> descriptions <span class="token operator">=</span> toDoList<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">\</span><span class="token punctuation">.</span>completed<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">\</span><span class="token punctuation">.</span>description<span class="token punctuation">)</span>
<span class="token keyword">let</span> descriptions2 <span class="token operator">=</span> toDoList<span class="token punctuation">.</span>filter <span class="token punctuation">{</span> <span class="token short-argument">$0</span><span class="token punctuation">.</span>completed <span class="token punctuation">}</span><span class="token punctuation">.</span>map <span class="token punctuation">{</span> <span class="token short-argument">$0</span><span class="token punctuation">.</span>description <span class="token punctuation">}</span>
</code></pre>
<p>KeyPath 式の副作用は、式が評価される時点でのみ評価されます。例えば、KeyPath 式でサブスクリプトの内側の関数呼び出しを行うと、関数は、KeyPath が使用される度にではなく、式を評価する際に 1 回だけ呼び出されます。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">func</span> <span class="token function-definition function">makeIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Made an index"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
<span class="token comment">// 下の行は makeIndex() を呼び出します</span>
<span class="token keyword">let</span> taskKeyPath <span class="token operator">=</span> <span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token class-name">Task</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">makeIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token comment">// Made an index</span>

<span class="token comment">// taskKeyPath を使用すると makeIndex() は再び呼び出されません。</span>
<span class="token keyword">let</span> someTask <span class="token operator">=</span> toDoList<span class="token punctuation">[</span>keyPath<span class="token punctuation">:</span> taskKeyPath<span class="token punctuation">]</span>
</code></pre>
<p>Objective-C API とやり取りするコード内の KeyPath の使用方法の詳細については、<a href="https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift" target="_blank">Using Objective-C Runtime Features in Swift</a>を参照ください。Key-Value Coding や Key-Value Observing については、<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i" target="_blank">Key-Value Coding Programming Guide</a>と<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank">Key-Value Observing Programming Guide</a>を参照ください。</p>
<blockquote>
<p>Grammar of a key-path expression:</p>
<p><em>key-path-expression</em> → <strong><code>\</code></strong> <em>type</em><em>?</em> <strong><code>.</code></strong> <em>key-path-components</em> \
<em>key-path-components</em> → <em>key-path-component</em> | <em>key-path-component</em> <strong><code>.</code></strong> <em>key-path-components</em> \
<em>key-path-component</em> → <em>identifier</em> <em>key-path-postfixes</em><em>?</em> | <em>key-path-postfixes</em></p>
<p><em>key-path-postfixes</em> → <em>key-path-postfix</em> <em>key-path-postfixes</em><em>?</em> \
<em>key-path-postfix</em> → <strong><code>?</code></strong> | <strong><code>!</code></strong> | <strong><code>self</code></strong> | <strong><code>[</code></strong> <em>function-call-argument-list</em> <strong><code>]</code></strong></p>
</blockquote>
<h3 id="selector-式selector-expression"><a id="selector-expression">Selector 式(Selector Expression)</a></h3>
<p>セレクタ式を使用すると、Objective-C のメソッドまたはプロパティの get や set を参照するために使用されるセレクタにアクセスできます。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token other-directive property">#selector</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#method</span> name#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
<span class="token other-directive property">#selector</span><span class="token punctuation">(</span>getter<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token other-directive property">#property</span> name#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
<span class="token other-directive property">#selector</span><span class="token punctuation">(</span>setter<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token other-directive property">#property</span> name#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<p>メソッド名とプロパティ名は、Objective-C ランタイムで使用可能なメソッドまたはプロパティを参照する必要があります。セレクタ式の値は <code>Selector</code> 型のインスタンスです。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">class</span> <span class="token class-name">SomeClass</span><span class="token punctuation">:</span> <span class="token class-name">NSObject</span> <span class="token punctuation">{</span>
    <span class="token attribute atrule">@objc</span> <span class="token keyword">let</span> property<span class="token punctuation">:</span> <span class="token class-name">String</span>

    <span class="token attribute atrule">@objc</span><span class="token punctuation">(</span>doSomethingWithInt<span class="token punctuation">:</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token function-definition function">doSomething</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> x<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

    <span class="token keyword">init</span><span class="token punctuation">(</span>property<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>property <span class="token operator">=</span> property
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> selectorForMethod <span class="token operator">=</span> <span class="token other-directive property">#selector</span><span class="token punctuation">(</span><span class="token class-name">SomeClass</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token omit keyword">_</span><span class="token punctuation">:</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> selectorForPropertyGetter <span class="token operator">=</span> <span class="token other-directive property">#selector</span><span class="token punctuation">(</span>getter<span class="token punctuation">:</span> <span class="token class-name">SomeClass</span><span class="token punctuation">.</span>property<span class="token punctuation">)</span>
</code></pre>
<p>プロパティの get のセレクタを作成すると、プロパティ名は変数または定数プロパティを参照できます。対照的に、set のセレクタを作成すると、プロパティ名は変数プロパティのみ参照しなければなりません。</p>
<p><em>method name</em> は、同じ名前でシグネチャが異なるメソッド間の曖昧さを軽減するために <code>as</code> 演算子と一緒にグループ化するための括弧を含めることができます。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">extension</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>
    <span class="token attribute atrule">@objc</span><span class="token punctuation">(</span>doSomethingWithString<span class="token punctuation">:</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token function-definition function">doSomething</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> x<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> anotherSelector <span class="token operator">=</span> <span class="token other-directive property">#selector</span><span class="token punctuation">(</span><span class="token class-name">SomeClass</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token omit keyword">_</span><span class="token punctuation">:</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token punctuation">(</span><span class="token class-name">SomeClass</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span>
</code></pre>
<p>セレクタが実行時ではなくコンパイル時に作成されるため、コンパイラはメソッドまたはプロパティが存在すること、およびそれらが Objective-C ランタイムに公開されていることを確認できます。</p>
<blockquote>
<p>NOTE
メソッド名とプロパティ名は式ですが、それらは決して評価されません。</p>
</blockquote>
<p>Objective-C API とやり取りする Swift コードでセレクタを使用する方法の詳細については、<a href="https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift" target="_blank">Using Objective-C Runtime Features in Swift</a>を参照ください。</p>
<blockquote>
<p>Grammar of a selector expression:</p>
<p><em>selector-expression</em> → <strong><code>#selector</code></strong> <strong><code>(</code></strong> <em>expression</em> <strong><code>)</code></strong> \
<em>selector-expression</em> → <strong><code>#selector</code></strong> <strong><code>(</code></strong> <strong><code>getter:</code></strong> <em>expression</em> <strong><code>)</code></strong> \
<em>selector-expression</em> → <strong><code>#selector</code></strong> <strong><code>(</code></strong> <strong><code>setter:</code></strong> <em>expression</em> <strong><code>)</code></strong></p>
</blockquote>
<h3 id="keypath-文字列式key-path-string-expression">KeyPath 文字列式(Key-Path String Expression)</h3>
<p>KeyPath 文字列式を使用すると、Key-Value Coding や Key-Value Observing API で使用するために、Objective-C のプロパティを参照するための文字列にアクセスできます。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token other-directive property">#keyPath</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#property</span> name#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<p><em>property name</em> は、Objective-C ランタイムで使用可能なプロパティを参照する必要があります。コンパイル時には、KeyPath 文字列式は文字列リテラルに置き換えられます。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">class</span> <span class="token class-name">SomeClass</span><span class="token punctuation">:</span> <span class="token class-name">NSObject</span> <span class="token punctuation">{</span>
    <span class="token attribute atrule">@objc</span> <span class="token keyword">var</span> someProperty<span class="token punctuation">:</span> <span class="token class-name">Int</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>someProperty<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>someProperty <span class="token operator">=</span> someProperty
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">SomeClass</span><span class="token punctuation">(</span>someProperty<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> keyPath <span class="token operator">=</span> <span class="token other-directive property">#keyPath</span><span class="token punctuation">(</span><span class="token class-name">SomeClass</span><span class="token punctuation">.</span>someProperty<span class="token punctuation">)</span>

<span class="token keyword">if</span> <span class="token keyword">let</span> value <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>forKey<span class="token punctuation">:</span> keyPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 12</span>
</code></pre>
<p>クラス内で KeyPath 文字列式を使用すると、クラス名なしでプロパティ名だけを書くことでそのクラスのプロパティを参照できます。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">extension</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function-definition function">getSomeKeyPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token other-directive property">#keyPath</span><span class="token punctuation">(</span>someProperty<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span>keyPath <span class="token operator">==</span> c<span class="token punctuation">.</span><span class="token function">getSomeKeyPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// true</span>
</code></pre>
<p>KeyPath 文字列は、実行時ではなくコンパイル時に作成されているため、コンパイラはプロパティが存在すること、およびそのプロパティが Objective-C ランタイムに公開されていることを確認できます。</p>
<p>Objective-C API とやり取りする Swift コードで KeyPath を使用する方法の詳細については、<a href="https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift" target="_blank">Using Objective-C Runtime Features in Swift</a>を参照ください。Key-Value Coding と Key-Value Observing については、<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i" target="_blank">Key-Value Coding Programming Guide</a>と<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank">Key-Value Observing Programming Guide</a>を参照ください。</p>
<blockquote>
<p>NOTE
プロパティ名は式ですが、それらは決して評価されません。</p>
<p>Grammar of a key-path string expression:</p>
<p><em>key-path-string-expression</em> → <strong><code>#keyPath</code></strong> <strong><code>(</code></strong> <em>expression</em> <strong><code>)</code></strong></p>
</blockquote>
<h2 id="後置式postfix-expressions"><a id="postfix-expressions">後置式(Postfix Expressions)</a></h2>
<p><em>後置式</em>は、後置演算子またはその他の後置構文を式に適用することによって形成されます。構文的には、全ての基本式も後置式です。</p>
<p>これらの演算子の動作については、<a href="../language-guide/basic-operators.html">Basic Operators(基本演算子)</a>と<a href="../language-guide/advanced-operators.html">Advanced Operators(高度な演算子)</a>を参照ください。</p>
<p>Swift 標準ライブラリによって提供されている演算子については、<a href="https://developer.apple.com/documentation/swift/swift_standard_library/operator_declarations" target="_blank">Operator Declarations(演算子宣言)</a>を参照ください。</p>
<blockquote>
<p>Grammar of a postfix expression:</p>
<p><em>postfix-expression</em> → <em>primary-expression</em> \
<em>postfix-expression</em> → <em>postfix-expression</em> <em>postfix-operator</em> \
<em>postfix-expression</em> → <em>function-call-expression</em> \
<em>postfix-expression</em> → <em>initializer-expression</em> \
<em>postfix-expression</em> → <em>explicit-member-expression</em> \
<em>postfix-expression</em> → <em>postfix-self-expression</em> \
<em>postfix-expression</em> → <em>subscript-expression</em> \
<em>postfix-expression</em> → <em>forced-value-expression</em> \
<em>postfix-expression</em> → <em>optional-chaining-expression</em></p>
</blockquote>
<h3 id="関数呼び出し式function-call-expression"><a id="function-call-expression">関数呼び出し式(Function Call Expression)</a></h3>
<p><em>関数呼び出し式</em>は、関数名とそれに続く関数の引数のカンマ区切りのリストからなる関数名で構成されています。関数呼び出し式は形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token literal constant">#function</span> name#<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#argument</span> value <span class="token number">1</span>#<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token other-directive property">#argument</span> value <span class="token number">2</span>#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<p><em>function name</em> は、関数型の任意の式です。</p>
<p>関数定義にパラメータ名が含まれている場合、関数呼び出しは、コロン(<code>:</code>)で区切られた引数値の前に名前を含める必要があります。この種の関数呼び出し式は形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token literal constant">#function</span> name#<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#argument</span> name <span class="token number">1</span>#<span class="token operator">&gt;</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token other-directive property">#argument</span> value <span class="token number">1</span>#<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token other-directive property">#argument</span> name <span class="token number">2</span>#<span class="token operator">&gt;</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token other-directive property">#argument</span> value <span class="token number">2</span>#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<p>関数呼び出し式は、閉じ括弧(<code>}</code>)の直後にクロージャ式の形で末尾クロージャを含めることができます。末尾クロージャは、最後の括弧内の引数の後の関数型の引数と解釈されます。最初のクロージャ式に引数ラベルは付けません。次のクロージャ式の前には引数ラベルを付けます。下記の例は、末尾クロージャの構文を使用して、 末尾クロージャを使用しない関数呼び出しバージョンと同等だということを示しています:</p>
<pre class="language-"><code class="lang-swift"><span class="token comment">// someFunction 関数は引数として整数とクロージャを受け取ります</span>
<span class="token function">someFunction</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> x<span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">==</span> <span class="token number">13</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">someFunction</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">==</span> <span class="token number">13</span> <span class="token punctuation">}</span>

<span class="token comment">// anotherFunction 関数は引数として整数と 2 つのクロージャを受け取ります</span>
<span class="token function">anotherFunction</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> x<span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">==</span> <span class="token number">13</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> g<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">anotherFunction</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">==</span> <span class="token number">13</span> <span class="token punctuation">}</span> g<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre>
<p>末尾クロージャが関数の唯一の引数の場合は、括弧を省略できます。</p>
<pre class="language-"><code class="lang-swift"><span class="token comment">// someMethod は唯一の引数としてクロージャを受け取ります</span>
myData<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">==</span> <span class="token number">13</span> <span class="token punctuation">}</span>
myData<span class="token punctuation">.</span>someMethod <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">==</span> <span class="token number">13</span> <span class="token punctuation">}</span>
</code></pre>
<p>引数に末尾クロージャを含めるために、コンパイラは次のように左から右へ関数のパラメータを調べます:</p>
<table>
<thead>
<tr>
<th style="text-align:center">末尾クロージャ</th>
<th style="text-align:center">パラメータ</th>
<th style="text-align:center">アクション</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ラベルあり</td>
<td style="text-align:center">ラベルあり</td>
<td style="text-align:center">ラベルが同じ場合、クロージャはパラメータと一致します。それ以外の場合は、スキップされます</td>
</tr>
<tr>
<td style="text-align:center">ラベルあり</td>
<td style="text-align:center">ラベルなし</td>
<td style="text-align:center">パラメータはスキップされます</td>
</tr>
<tr>
<td style="text-align:center">ラベルなし</td>
<td style="text-align:center">ラベルあり/なし</td>
<td style="text-align:center">下記に定義されているように、パラメータが関数型と見なされる場合、クロージャはパラメータと一致します。それ以外の場合は、スキップされます。</td>
</tr>
</tbody>
</table>
<p>末尾クロージャは、それが一致する関数のパラメータに渡されます。スキャンプロセス中にスキップされたパラメータには、値が渡されません。例えば、デフォルトのパラメータを使用できます。一致するパラメータを見つけた後、スキャンは次の末尾クロージャと次のパラメータに続きます。マッチングプロセスの最後に、全ての末尾クロージャが一致している必要があります。</p>
<p><em>構造上</em>、パラメータが in-out パラメータではなく、次のいずれかの場合、パラメータは関数型と見なされます:</p>
<ul>
<li><code>(Bool) -&gt; Int</code> のようにパラメータの型が関数型</li>
<li><code>@autoclosure () -&gt; ((Bool) -&gt; Int)</code> のように、ラップされた式の型が関数型の自動クロージャパラメータ</li>
<li><code>((Bool) -&gt; Int)...</code> のように、配列要素の型が関数型の可変長パラメータ</li>
<li><code>Optional<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>(Bool)</span> <span class="token attr-name">-</span><span class="token punctuation">&gt;</span></span> Int&gt;</code> のように、型がオプショナルの 1 つ以上の層にラップされているパラメータ</li>
<li><code>(Optional<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>(Bool)</span> <span class="token attr-name">-</span><span class="token punctuation">&gt;</span></span> Int&gt;)...</code> のように、上記の許可された型を組み合わせたパラメータ</li>
</ul>
<p>末尾クロージャが機能的には関数型のように見えるが関数ではないパラメータと一致する場合、クロージャは必要に応じてラップされます。例えば、パラメータの型がオプショナルの型の場合、クロージャは自動的に <code>Optional</code> でラップされます</p>
<p>これは右から左にマッチングを実行していた Swift 5.3 以前のコードから移行を簡単にするために、スキャン方向で異なる結果を生成する場合は、古い右から左へ順序付けされ、コンパイラは警告を生成します。それ以降の Swift のバージョンでは常に左から右へ正しく順序付けします。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">typealias</span> <span class="token class-name">Callback</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span>
<span class="token keyword">func</span> <span class="token function-definition function">someFunction</span><span class="token punctuation">(</span>firstClosure<span class="token punctuation">:</span> <span class="token class-name">Callback</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token nil constant">nil</span><span class="token punctuation">,</span>
                  secondClosure<span class="token punctuation">:</span> <span class="token class-name">Callback</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token nil constant">nil</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> first <span class="token operator">=</span> firstClosure<span class="token operator">?</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> second <span class="token operator">=</span> secondClosure<span class="token operator">?</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>first <span class="token operator">??</span> <span class="token string-literal"><span class="token string">"-"</span></span><span class="token punctuation">,</span> second <span class="token operator">??</span> <span class="token string-literal"><span class="token string">"-"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">someFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// - -</span>
someFunction <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token short-argument">$0</span> <span class="token operator">+</span> <span class="token number">100</span> <span class="token punctuation">}</span>  <span class="token comment">// Ambiguous</span>
someFunction <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token short-argument">$0</span> <span class="token punctuation">}</span> secondClosure<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token short-argument">$0</span> <span class="token punctuation">}</span>  <span class="token comment">// 10 20</span>
</code></pre>
<p>上記の例では、"Ambiguous"とマークされている関数の呼び出しは"- 120"が出力され、Swift 5.3 ではコンパイラが警告を生成します。それ以降の Swift のバージョンでは "110 -"が出力されます。</p>
<p>クラス、構造体、または列挙型は、<a href="declarations.html#methods-with-special-names" target="_self">Methods with Special Names(特別な名前のメソッド)</a>で説明されているような、いくつかのメソッドの 1 つを宣言することで、関数呼び出しの糖衣構文(シンタックスシュガー)を使うことができます。</p>
<h4 id="ポインタ型への暗黙変換implicit-conversion-to-a-pointer-type"><a id="implicit-conversion-to-a-pointer-type">ポインタ型への暗黙変換(Implicit Conversion to a Pointer Type)</a></h4>
<p>関数呼び出し式で、引数とパラメータが異なる場合、コンパイラは次のリストの暗黙的な変換の 1 つを適用することによって、その型が一致するようにします。</p>
<ul>
<li><code>inout SomeType</code> は、<code>UnsafePointer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SomeType</span><span class="token punctuation">&gt;</span></span></code> または <code>UnsafeMutablePointer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SomeType</span><span class="token punctuation">&gt;</span></span></code> になる可能性があります</li>
<li><code>inout Array<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SomeType</span><span class="token punctuation">&gt;</span></span></code> は、<code>UnsafePointer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SomeType</span><span class="token punctuation">&gt;</span></span></code> または <code>UnsafeMutablePointer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SomeType</span><span class="token punctuation">&gt;</span></span></code> になる可能性があります</li>
<li><code>Array<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SomeType</span><span class="token punctuation">&gt;</span></span></code> は、<code>UnsafePointer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SomeType</span><span class="token punctuation">&gt;</span></span></code> になる可能性があります</li>
<li><code>String</code> は <code>UnsafePointer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>CChar</span><span class="token punctuation">&gt;</span></span></code> になる可能性があります</li>
</ul>
<p>次の 2 つの関数呼び出しは同等です:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">func</span> <span class="token function-definition function">unsafeFunction</span><span class="token punctuation">(</span>pointer<span class="token punctuation">:</span> <span class="token class-name">UnsafePointer</span><span class="token operator">&lt;</span><span class="token class-name">Int</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> myNumber <span class="token operator">=</span> <span class="token number">1234</span>

<span class="token function">unsafeFunction</span><span class="token punctuation">(</span>pointer<span class="token punctuation">:</span> <span class="token operator">&amp;</span>myNumber<span class="token punctuation">)</span>
<span class="token function">withUnsafePointer</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> myNumber<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">unsafeFunction</span><span class="token punctuation">(</span>pointer<span class="token punctuation">:</span> <span class="token short-argument">$0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre>
<p>これらの暗黙の変換によって作成されたポインタは、関数呼び出しの間だけ有効です。未定義の動作を避けるために、関数呼び出しが終了した後までポインタを保持しないようにしてください。</p>
<blockquote>
<p>NOTE
配列を暗黙的に安全でないポインタに変換すると、Swift は、配列のストレージが必要に応じて配列を変換またはコピーすることによって連続していることを保証します。例えば、この構文は、そのストレージに関する API の契約がない(動作が定義されているか定かではない) <code>NSArray</code> のサブクラスから <code>Array</code> にブリッジされた配列でこの構文を使用できます。配列のストレージがすでに連続していることを保証する必要がある場合、暗黙の変換を行わないようにするために、<code>Array</code> の代わりに <code>ContigureArray</code> を使用します</p>
</blockquote>
<p><code>withUnsafePointer(to:)</code> のような明示的な機能の代わりに、<code>&amp;</code> を使うことで、低レベルの C 言語の関数を呼び出しやすくするのに役立ちます。ただし、他の Swift コードから関数を呼び出すときは、安全でない API を明示的に使用する代わりとして <code>&amp;</code> を使用しないでください。</p>
<blockquote>
<p>Grammar of a function call expression:</p>
<p><em>function-call-expression</em> → <em>postfix-expression</em> <em>function-call-argument-clause</em> \
<em>function-call-expression</em> → <em>postfix-expression</em> <em>function-call-argument-clause</em><em>?</em> <em>trailing-closures</em></p>
<p><em>function-call-argument-clause</em> → <strong><code>(</code></strong> <strong><code>)</code></strong> | <strong><code>(</code></strong> <em>function-call-argument-list</em> <strong><code>)</code></strong> \
<em>function-call-argument-list</em> → <em>function-call-argument</em> | <em>function-call-argument</em> <strong><code>,</code></strong> <em>function-call-argument-list</em> \
<em>function-call-argument</em> → <em>expression</em> | <em>identifier</em> <strong><code>:</code></strong> <em>expression</em> \
<em>function-call-argument</em> → <em>operator</em> | <em>identifier</em> <strong><code>:</code></strong> <em>operator</em></p>
<p><em>trailing-closures</em> → <em>closure-expression</em> <em>labeled-trailing-closures</em><em>?</em> \
<em>labeled-trailing-closures</em> → <em>labeled-trailing-closure</em> <em>labeled-trailing-closures</em><em>?</em> \
<em>labeled-trailing-closure</em> → <em>identifier</em> <strong><code>:</code></strong> <em>closure-expression</em></p>
</blockquote>
<h3 id="イニシャライザ式initializer-expression"><a id="initializer-expression">イニシャライザ式(Initializer Expression)</a></h3>
<p><em>イニシャライザ式</em>は型のイニシャライザへアクセスします。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token other-directive property">#initializer</span> arguments#<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<p>イニシャライザ式を使用して、型の新しいインスタンスを初期化します。スーパークラスのイニシャライザに委譲するイニシャライザ式を使用することもできます。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">class</span> <span class="token class-name">SomeSubClass</span><span class="token punctuation">:</span> <span class="token class-name">SomeSuperClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// subclass の初期化処理をここに</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>関数のように、イニシャライザを値として使用することができます。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token comment">// 型注釈は、String に複数のイニシャイザがあるため必要です</span>
<span class="token keyword">let</span> initializer<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">init</span>
<span class="token keyword">let</span> oneTwoThree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>initializer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">""</span></span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>oneTwoThree<span class="token punctuation">)</span>
<span class="token comment">// 123</span>
</code></pre>
<p>名前で型を指定した場合は、イニシャライザ式を使用せずに型のイニシャライザにアクセスできます。他の場合では、イニシャライザ式を使用する必要があります。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">SomeType</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment">// 有効</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">SomeType</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span>       <span class="token comment">// これも有効</span>

<span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> someValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">)</span>  <span class="token comment">// 有効</span>
<span class="token keyword">let</span> s4 <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> someValue<span class="token punctuation">)</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span>       <span class="token comment">// エラー</span>
</code></pre>
<blockquote>
<p>Grammar of an initializer expression:</p>
<p><em>initializer-expression</em> → <em>postfix-expression</em> <strong><code>.</code></strong> <strong><code>init</code></strong> \
<em>initializer-expression</em> → <em>postfix-expression</em> <strong><code>.</code></strong> <strong><code>init</code></strong> <strong><code>(</code></strong> <em>argument-names</em> <strong><code>)</code></strong></p>
</blockquote>
<h3 id="明示的メンバ式explicit-member-expression"><a id="explicit-member-expression">明示的メンバ式(Explicit Member Expression)</a></h3>
<p><em>明示的メンバ式</em>では、名前付き型、タプル、またはモジュールのメンバへアクセスできます。アイテムとそのメンバの識別子の間のピリオド(<code>.</code>)で構成されています。</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span><span class="token operator">.&lt;</span><span class="token other-directive property">#member</span> name#<span class="token operator">&gt;</span>
</code></pre>
<p>名前付き型のメンバは、型の宣言または extension の一部で指定されます。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> someProperty <span class="token operator">=</span> <span class="token number">42</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">SomeClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> c<span class="token punctuation">.</span>someProperty  <span class="token comment">// メンバへのアクセス</span>
</code></pre>
<p>タプルのメンバは、0 から始まる整数が順番に暗黙的に指定されており、使用することができます。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>
t<span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token number">1</span>
<span class="token comment">// t は今 (20, 20, 30)</span>
</code></pre>
<p>モジュールのメンバはそのモジュールの最上位の宣言にアクセスします。</p>
<p><code>dynamicMemberLookup</code> 属性で宣言された型には、<a href="attributes.html">Attributes(属性)</a>で説明されているように、実行時に検索できるメンバが含まれています。</p>
<p>パラメータ名だけが異なるメソッドまたはイニシャライザを区別するには、パラメータ名を括弧内に入れ、パラメータ名の後にコロン(<code>:</code>)を書きます。名前のない引数にはアンダースコア(<code>_</code>)を書きます。オーバーロードされたメソッドを区別するには、型注釈を使用してください。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function-definition function">someMethod</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">func</span> <span class="token function-definition function">someMethod</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">func</span> <span class="token function-definition function">overloadedMethod</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">func</span> <span class="token function-definition function">overloadedMethod</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token class-name">Bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token class-name">SomeClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> a <span class="token operator">=</span> instance<span class="token punctuation">.</span>someMethod              <span class="token comment">// あいまい</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span>y<span class="token punctuation">:</span><span class="token punctuation">)</span>        <span class="token comment">// 明確</span>

<span class="token keyword">let</span> d <span class="token operator">=</span> instance<span class="token punctuation">.</span>overloadedMethod        <span class="token comment">// あいまい</span>
<span class="token keyword">let</span> d <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">overloadedMethod</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span>y<span class="token punctuation">:</span><span class="token punctuation">)</span>  <span class="token comment">// まだあいまい</span>
<span class="token keyword">let</span> d<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token class-name">Int</span><span class="token punctuation">,</span> <span class="token class-name">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span>  <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">overloadedMethod</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span>y<span class="token punctuation">:</span><span class="token punctuation">)</span>  <span class="token comment">// 明確</span>
</code></pre>
<p>ピリオドが行の先頭に示されている場合は、暗黙メンバ式としてではなく、明示的メンバ式の一部として解釈されます。例えば、次のリストはメソッドチェーンで呼び出しが複数行にわたって分割された呼び出しを示しています:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
    <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span>filter <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>map <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token punctuation">}</span>
</code></pre>
<p>それぞれのメソッドが呼ばれた時に制御するための条件付きコンパイルブロックを複数行のチェーン構文と組み合わせることもできます。例えば、次のコードは、iOS では異なるフィルタ条件が使用されます:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span>
<span class="token directive property"><span class="token directive-name">#if</span> os<span class="token punctuation">(</span>iOS<span class="token punctuation">)</span></span>
<span class="token punctuation">.</span>filter <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">&lt;</span> <span class="token number">40</span> <span class="token punctuation">}</span>
<span class="token directive property"><span class="token directive-name">#else</span></span>
<span class="token punctuation">.</span>filter <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">&gt;</span> <span class="token number">25</span> <span class="token punctuation">}</span>
<span class="token directive property"><span class="token directive-name">#endif</span></span>
</code></pre>
<p><code>#if</code> と <code>#endif</code>、その他のコンパイルディレクティブの間に、条件付きコンパイルブロックに、暗黙メンバ式とそれに続く 0 個以上の接尾辞を含めて、後置式を形成することができます。また、他の条件付きコンパイルブロック、またはこれらの式とブロックの組み合わせも含めることができます。</p>
<p>この構文は明示的メンバ式を記載できるところんまらどこでも使用可能ですが、トップレベルのコードでは使用できません。</p>
<p>条件付きコンパイルブロックの中では、<code>#if</code> コンパイルディレクティブの条件分岐は、少なくとも 1 つの式を含めなければなりません。その他の分岐は空でも構いません。</p>
<blockquote>
<p>Grammar of an explicit member expression:</p>
<p><em>explicit-member-expression</em> → <em>postfix-expression</em> <strong><code>.</code></strong> <em>decimal-digits</em> \
<em>explicit-member-expression</em> → <em>postfix-expression</em> <strong><code>.</code></strong> <em>identifier</em> <em>generic-argument-clause</em><em>?</em> \
<em>explicit-member-expression</em> → <em>postfix-expression</em> <strong><code>.</code></strong> <em>identifier</em> <strong><code>(</code></strong> <em>argument-names</em> <strong><code>)</code></strong> \
<em>explicit-member-expression</em> → <em>postfix-expression</em> <em>conditional-compilation-block</em></p>
<p><em>argument-names</em> → <em>argument-name</em> <em>argument-names</em><em>?</em> \
<em>argument-name</em> → <em>identifier</em> <strong><code>:</code></strong></p>
</blockquote>
<h3 id="後置-self-式postfix-self-expression">後置 self 式(Postfix Self Expression)</h3>
<p>後置 <code>self</code> 式は、型や式の直後に <code>.self</code> を付けて構成します。次の形式があります:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token keyword">self</span>
<span class="token operator">&lt;</span><span class="token other-directive property">#type</span>#<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token keyword">self</span>
</code></pre>
<p>最初の形式は <em>expression</em> の値に評価されます。例えば、<code>x.self</code> は <code>x</code> と評価されます。</p>
<p>2 番目の形式は <em>type</em> の値に評価されます。この形式を使用して、型に値としてアクセスできます。例えば、<code>SomeClass.self</code> は <code>SomeClass</code> 型自体に評価されるため、型レベルの引数を受け取る関数またはメソッドに渡すことができます。</p>
<blockquote>
<p>Grammar of a postfix self expression:</p>
<p><em>postfix-self-expression</em> → <em>postfix-expression</em> <strong><code>.</code></strong> <strong><code>self</code></strong></p>
</blockquote>
<h3 id="サブスクリプト式subscript-expression">サブスクリプト式(Subscript Expression)</h3>
<p><em>サブスクリプト式</em>は、対応するサブスクリプト宣言の get と set を使用してサブスクリプトへのアクセスすることができます。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token other-directive property">#index</span> expressions#<span class="token operator">&gt;</span><span class="token punctuation">]</span>
</code></pre>
<p>サブスクリプト式の値を評価するには、<em>expression</em> 型のサブスクリプトの get をサブスクリプトのパラメータとして<em>インデックス式</em>を渡して呼び出します。値を設定するために、サブスクリプトの set を同じ方法で呼び出します。</p>
<p>サブスクリプト宣言については、<a href="declarations.html#protocol-subscript-declaration">Protocol Subscript Declaration(プロトコルサブスクリプト宣言)</a>を参照ください。</p>
<blockquote>
<p>Grammar of a subscript expression:</p>
<p><em>subscript-expression</em> → <em>postfix-expression</em> <strong><code>[</code></strong> <em>function-call-argument-list</em> <strong><code>]</code></strong></p>
</blockquote>
<h3 id="強制アンラップ式forced-value-expression">強制アンラップ式(Forced-Value Expression)</h3>
<p><em>強制アンラップ式</em>は、特定の値が <code>nil</code> ではないオプショナル値を表します。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;!</span>
</code></pre>
<p><em>expression</em> の値が <code>nil</code> でない場合、オプショナル値はアンラップされ、対応するオプショナルの非オプショナルの型で返されます。それ以外の場合は、実行時エラーが発生します。</p>
<p>強制アンラップされた値は、値自体を変化させる、またはその値のメンバの 1 つに割り当てることによって、変更できます。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">var</span> x<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token number">0</span>
x<span class="token operator">!</span> <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token comment">// x は 1</span>

<span class="token keyword">var</span> someDictionary <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"a"</span></span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"b"</span></span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
someDictionary<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"a"</span></span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>
<span class="token comment">// someDictionary は ["a": [100, 2, 3], "b": [10, 20]]</span>
</code></pre>
<blockquote>
<p>Grammar of a forced-value expression:</p>
<p><em>forced-value-expression</em> → <em>postfix-expression</em> <strong><code>!</code></strong></p>
</blockquote>
<h3 id="オプショナルチェーン式optional-chaining-expression"><a id="optional-chaining-expression">オプショナルチェーン式(Optional-Chaining Expression)</a></h3>
<p><em>オプショナルチェーン式</em>は後置式で、オプショナル値を使用するための簡単な構文を提供します。形式は次のとおりです:</p>
<pre class="language-"><code class="lang-swift"><span class="token operator">&lt;</span><span class="token other-directive property">#expression</span>#<span class="token operator">&gt;?</span>
</code></pre>
<p>後置 <code>?</code> 演算子は式の値を変更せずに式からオプショナルチェーン式を作成します。</p>
<p>オプショナルチェーン式は、後置式で使用しなければならず、後置式を特別な方法で評価します。オプショナルチェーン式の値が <code>nil</code> の場合、後置式の他の全ての操作は無視され、後置式全体が <code>nil</code> に評価されます。<code>nil</code> ではない場合、値はアンラップされ、後置式の残りの部分を評価するために使用されます。どちらの場合も、後置式の値は依然としてオプショナル型です。</p>
<p>オプショナルチェーン式を含む後置式が他の後置式の内側にネストされている場合は、最も外側の式だけがオプショナル型を返します。下記の例では、<code>c</code> が <code>nil</code> ではない場合、その値はアンラップされ、その値は <code>.performAction()</code> を評価するために使用される <code>.property</code> を評価するために使用されます。全体の式 <code>c？.property.performAction()</code> はオプショナルの型の値を持ちます。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">var</span> c<span class="token punctuation">:</span> <span class="token class-name">SomeClass</span><span class="token operator">?</span>
<span class="token keyword">var</span> result<span class="token punctuation">:</span> <span class="token class-name">Bool</span><span class="token operator">?</span> <span class="token operator">=</span> c<span class="token operator">?</span><span class="token punctuation">.</span>property<span class="token punctuation">.</span><span class="token function">performAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>次の例は、オプショナルチェーンを使用せずに上記の例の動作を表現しています。</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">var</span> result<span class="token punctuation">:</span> <span class="token class-name">Bool</span><span class="token operator">?</span>
<span class="token keyword">if</span> <span class="token keyword">let</span> unwrappedC <span class="token operator">=</span> c <span class="token punctuation">{</span>
    result <span class="token operator">=</span> unwrappedC<span class="token punctuation">.</span>property<span class="token punctuation">.</span><span class="token function">performAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>オプショナルチェーン式のアンラップ値は、その値自体を変える、またはその値のメンバに代入することで変更できます。オプショナルチェーン式の値が <code>nil</code> の場合、代入演算子の右側の式は評価されません。例えば:</p>
<pre class="language-"><code class="lang-swift"><span class="token keyword">func</span> <span class="token function-definition function">someFunctionWithSideEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">42</span>  <span class="token comment">// 実際の副作用はありません</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> someDictionary <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"a"</span></span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"b"</span></span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

someDictionary<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"not here"</span></span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">someFunctionWithSideEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// someFunctionWithSideEffects は評価されません</span>
<span class="token comment">// someDictionary はまだ ["a": [1, 2, 3], "b": [10, 20]]</span>

someDictionary<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"a"</span></span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">someFunctionWithSideEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// someFunctionWithSideEffects は評価され、42 を返します</span>
<span class="token comment">// someDictionary は今 ["a": [42, 2, 3], "b": [10, 20]]</span>
</code></pre>
<blockquote>
<p>Grammar of an optional-chaining expression:</p>
<p><em>optional-chaining-expression</em> → <em>postfix-expression</em> <strong><code>?</code></strong></p>
</blockquote>
</body></html>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="types.html" class="navigation navigation-prev " aria-label="Previous page: 型(Types)">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="statements.html" class="navigation navigation-next " aria-label="Next page: 文(Statements)">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"式(Expressions)","level":"4.4","depth":1,"next":{"title":"文(Statements)","level":"4.5","depth":1,"path":"language-reference/statements.md","ref":"language-reference/statements.md","articles":[]},"previous":{"title":"型(Types)","level":"4.3","depth":1,"path":"language-reference/types.md","ref":"language-reference/types.md","articles":[]},"dir":"ltr"},"config":{"plugins":["back-to-top-button","collapsible-chapters","copy-code-button","custom-favicon","edit-link","expand-active-chapter","-highlight","hide-published-with","insert-logo","intopic-toc","katex","prism"],"styles":{"website":"styles/website.css"},"pluginsConfig":{"prism":{},"intopic-toc":{"selector":".markdown-section h1, .markdown-section h2, .markdown-section h3, .markdown-section h4, .markdown-section h5, .markdown-section h6","mode":"nested","maxDepth":6,"isCollapsed":true,"isScrollspyActive":true,"visible":true,"label":"In this article"},"search":{},"collapsible-chapters":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"hide-published-with":{},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"favicon":"assets/favicon.ico","back-to-top-button":{},"custom-favicon":{},"expand-active-chapter":{},"copy-code-button":{},"edit-link":{"label":"このページを編集","base":"https://github.com/stzn/the-swift-programming-language-jp/edit/master"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"insert-logo":{"url":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAL8AAAA7CAYAAAAqy1vIAAAABmJLR0QA/wD/AP+gvaeTAAANsElEQVR42u1dC3QU1RkeEaXYYjzWFkQp4gF6BCsoJbsJr6BSCwgkGxKgyJtKRFAKQhT0gPIStcqjFEFQQykFpSCPKhU5FgFBwkPlodACEh6FQjbZ7Oa1r9v/n50Nm7v3zmNnNvvIfOd8Jzk7d/6dnfvdO//973/vCIIKlNqsD5VmWqeVZln/5siy7i7NSjsN/9uBfiCJAfG7LwAPwrVtgL/5jsy0VCIINwgmTOgFmSU0KMm0jgRhnYiRwCMhXmseychoaNagiYjgyLa0AREdSCDRU7QcKclK7WDWpAlNKLFZeoKAShNX+DV0Omypfc0aNaFO+NlpD6JokkD4QbqxMZs1a0IW9pxOKSCW80kk/CCvuXI6NzNr2AS/18+0Lk5C4YssybKuMWvYBBNX+3dpji5Csoofac9Kv9+saRPh0Z1M68yYijM7nZRNGBTt3n+RWdMmwgDiOBTrnrli2aukauNqUjqwa3S+w2Y9U8e39UYghlvzgLOBfwKuBa4Azgc+C+wCbGQqMEYo7m25FcThjblrYksjnmOHiffkUVL2+wFR+Y7iAZ1b1MEtRUHjGKMMSFSwErgZ+Bsh+WaocbIxH3gU+D1wHvBHEdj5MTANmAMcDbQBewB/pq/Xz7R0ihe/3DllBCF+H/GXXCPO50ZFwb2yPhrFisYxxZcqBc/j18BfJ5H45zJ+Y4GG81OBW4Fezv0ary/KY0vL0iXYqSDSgV0ME6j7i38ShL+ygrhmTjTY708bHaVKngSs1in8ID3A6UkgfHyKlTB+nx94m4rzhwPdCvdKp/hBEHoE5RicQao+WGWYr142cTAo3x9oANVV0AAmGCd+m2VKFCo53yDR03wtwcV/k0yHoOR+tgdWqbhH+sTvsFknqhJPbjdSNqYfu/f/wzDi3rtTLGOESD3fFJIg/OUusUEYI37rLIMreLBMxeCj+mPgOOCDwKbAn0h+Kg6ExwC3SD09z8bIBG8AWzmunRJWcu5HOfAQcIdk5wnqvHaceuC5PZYpqiMyS+cS5wtPso+980fiObJffBLoFWn5a9NJKHwXzxHHE48a0QDmGFixPwVe4VTSHqki1KAt8HOOnWJgIs9O3wXcH/J7jgPvU3HeBca9KJTuuRy0iR9y86eqj8ikE/dXu0j5wlnMaA0e8546Thwjfkv0ulL+qspaDcDz9VfifIA+8afNN7BiZ3AE+1EE4cuGUhiUZW9Bgvf+DSTBPyD9TiXcwbkP3VWcq1X81nxNwgRh+y5fJJVrV4iCr3Vs+GPEd+US8V04R8rybPpcn8I9hEbl+0viSfwnGDf6ksrBHAuNOTYvSHMG9QVtOYPkW2IuftHHnzxM7Jndu7aHuTkYrsSBqhiunDw8YqFWvrc4TPz+inLuuEMlXzWogppzeqdXdNr9HcfuQ/VI/B0Yv79U5bnRF7/ol7/xohiV8Z49RcrGD6zt/y9+pUasrjlTIhIqhjlZcO/+NB7Eb+GItLdOu405A+DceiT+jozfXxJX4kdW/b0gIHKXk5TPm1rrWPUnG6TRqi8id8Uxqg/hwfXiU7EWfz+O+LsaYBtTIZZTDJ2cSwF2oqg1ae/nDBstNdq4h2GjGWPAS5dpRZVpRB0fwrivZQw7LA5knOvjlG2mS/w4AK7xzeEpUL1t/fUJL4j7e44fud5jfwE9dm53TbZxtpcFDIXGWPwZHPGPrYOesSXjezEmriVtYAXDxj6N17GXYYNeOTePUeavVJk2UZonUWK+PvFjDw0hSN/5s7WE6Rj9eGDCaszjxHftSs0x73ffip+pte13lnF7f5xbiKH4W3Nu6GGVEQ29+D7CaEgQZzjuwe0a3DN6AqtamseoP+IXRQ6RHRzg1gxMHSXENTfg6zsnDYWJKuf1YyXFqt0Wf6mdK/6qretiKX7Eec5NLZBmN6OJRYzvnaEjmhLkQJU2ejLO3ckol/ziF0UOiWiYj3Nd5eAG/eND0dXBFAXicV8/5vWSyoIlYaFSmrXOoSM/0NjQNYqh+BcI8glqvaIo/j6M79yu8twJMte9XKWNmYxzp0Uo/nuB9hA6OKFOuwo6OL+LVfZZw8QvRmigt8cBbii8506LvX/5wpdrcnZqXCScER7Vl+1ODelJlOB8bmQsxX+HwE7cCuUJaQDb0WDx3yKE5744Vbpcm2Wu9weV3/8Z49yOEYpfTbSnIu6iPcw0h7cXMEaoblK1fpXIsB4cXBtWONSZP1ZR/OLTI3biF6TQplflY/aMNNAcJEVb9IIlQKV06IZSzFzuOtsq2ECXzkWdc1lgr0WoX+IXQ6AfvscUKw6MvUWnGT4Mukgf1IoGVSx/XVH87j07Yi1+RDZDDErEx/i3wNeBjwiRreaayrA7WeGcroxBahH12cQI5jhWc8rWP/GLDWDTGqIV2Dicz48N5PXv+1yxvPeHf8eD+AUpzr5Lx+ALe+NlUvxZLR5g2NmkcM7LVHl8eiykPtuiYGMa43uHmuKnG8DmtUR7C/CR6u0bxRQJJWBUKU7EH0SmFPXw62gIn0hT/EpAN+OiEJ4F2kDmnH1UeVzf8Bj1mUvhSbSV8RRrZoqf1QAgJBk1QEOJM/GHhu/QLfmXIJ+vL7cWYLqgvKb3fca57Tllb2OMT9pJk2Pl1Oc9ODYaSA2MntsQTPFzFqbjzG9U4I9b8YeiiRSaxJVZhRoGyEQSt1wDYKUC5MmMTULLFYUc20Ydm6PB1Zpvil+hAUTjCYDzCgkgfhop0mTSOik8qdQAXlAIt/pUiuttqtyykGNPU8cOaJgjyDDFryZNefXSsFi/Lq/nvxcSUfx0mgCGPo/KiB9dkuYyNgqF8Px/Fk5T5fqHHGslhCeDsbYFWa9xfJCY4se9c4IpCobOAyyCyS6vxxDxew7tTXTxh8bfZ8sMlOXWCcxhlKczJ1szQpxNqDJ0vtBgxndd1BgZStyeH+P1uJVIMFHNsJngGXmyeTtqgdeXJOKXSxtA7pc5pxuj/AiqzFOMECeNN6kyqxiDePp7JiSt+DE92XP0oOhbV20oMGoRec2TxXvmpC7x46L5JBP/TQz3JOj6aJm1XUmV2cgIcdLopeA+jWFcV5vkFT/m2IzsLa7LDWwj4hRnYsueGaK/939lEvH+5zt9A16nQ1OKdAKIX2BMOgUpt4Z1E1X2VMgxXP9rZ4Q4aTRiDMDbyYRVz6r4LYk/4C17OjfMTfGePAaL2JcHkssUsjNr7DyZKa7q8p45Zdig13Poy7oWP6Yj7KC4XTAuj38KR/yNZc7JY5QPDpLTZUKcNLZQZSfJDJiX1QvxBzem4vnpuFYXtyyp3rFFdI8wqlOx8k1xhwcMcboP7Ca+4qtRm+tyvTS+LsVv5Yizs0Hiny+w9++Rwz0Cf93vLA2ipccGH0uf38Wwn1VvxC/23BNyie/qZRJvEPf0qTvxpzBi6yw/O1IcENgrxJRwkjpnifT5XpkQJ40WjLFGI8Zkmke6D/VH/IGF5X1hOeI3cdcA1O0TZNi+PZ8K7A1mu+u020eIfEuUxUL4gppbhdqbvbJCnDSOU3bQzfsz9dlulb+nrsV/n8DOoL2ZI34NO7YFmdMtkLTGWWAeC1SueqsuxZ/LESluX5gaoU1MHfgfx66a3Rn6MiaqRqsIcdJ4gzoHn5bHqM9eilPxt+Tcv9bM0lr26gyL2ICv7bt0Pi7Ej1slqtiodraBk1IHODcaK2qGwgBVoKIxOGDlLcFbr9IOvsChihGRUQpx0nhYCF/dRU++WeJU/CmceziNWVr1Ls0yuzfjABd3U46est3EvX9XYCANry/C3dxwIUvoGl9shIouG7x7zMCQZDtBfhvta8ClwAHAXwi1txzEXRIyJHfmrIwNXCZ5p4Zr2inI5wmp2TwXXQS5t8rYBfXbJ9a1+AUhfHFO0N3DLNkO0r1vIf7Vuz9/jbCG9RKjO5hjb1jiGixSr3x3obgHKG+iDF9lpDbJDV5KN1kwFv0EdfvIB+kQ1Kc4owC1boI1TcZekQY7H8nYWafBTizE/67K+ztJ95tZWOOB8gXPi+FN7LEjAS51xB5e1SZX8OTBvYJw8UuM3szSS+rljdxW46IUn9eKDjI2l2mwM07Gzqg4F38HQfmNLgHxR/OdXI5BPYhr1jNi7F+M9V8qggZRHZaWjMsX3Xs+EyfAMJwaUaoEvMguhu/kwgzINQaI3ie5SikRXgfm/l/i2O6vwc7dMtfYIs7FH5z08yqKPyZvY4ScIXSTjHztqGPoI8pvY7RZ7o5yagKG2t6K4ElwTgisr21pwDUUcHzeJhrtsNKsj2m0ESvxI9KktA8XV/xSrP9gMr99XQpznhbqDg2k8CQmg+Huari7wTYpFWID8B0h8KbCHIMEHwpcrngvxUhewdqUYaepRhu3M2wobdtyM+OcVjruBw7OfylFqHpKblELIbgOIeZvYK8Dmm9gN8FEua3TnSAQdzKLvzi7c3uzpk2wJ7syrYuTuNf/i1nDJriw53RKAaEUJaH4r7r6W5qaNWxCvgFkpd8PYilNIuG7IX2jp1mzJtS5P7b07iCaa0kg/DJHtqWPWaMmNAFE0waSwPYmrPAzrYftA9J+ZdakiYgAswA3QDrA8NIsy5EEEv4JWFI5juTk3GjWoAmDIkHpHTEpDMS1vtRm3Q896zn43w70x0jkdnFwnplWCNezARfkODLTUony3pYmTNTg/9SxB5WAdrwRAAAAAElFTkSuQmCC","style":"background: none;"}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"The Swift Programming Language日本語版","language":"ja","gitbook":"*","description":"[The Swift Programming Language](https://docs.swift.org/swift-book/)の日本語版です。"},"file":{"path":"language-reference/expressions.md","mtime":"2025-04-11T12:26:04.998Z","type":"markdown"},"gitbook":{"version":"5.1.5","time":"2025-04-11T12:26:22.606Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-collapsible-chapters/collapsible-chapters.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-copy-code-button/toggle.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-edit-link/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-expand-active-chapter/expand-active-chapter.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-hide-published-with/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-insert-logo/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-intopic-toc/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-intopic-toc/gumshoe.polyfills.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-intopic-toc/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

